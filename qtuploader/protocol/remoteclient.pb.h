// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: remoteclient.proto

#ifndef PROTOBUF_remoteclient_2eproto__INCLUDED
#define PROTOBUF_remoteclient_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace uploadercontrol {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_remoteclient_2eproto();
void protobuf_AssignDesc_remoteclient_2eproto();
void protobuf_ShutdownFile_remoteclient_2eproto();

class ClientRequest;
class ClientRequest_Authorization;
class ClientRequest_AddTask;
class ClientRequest_AddTask_File;
class ClientRequest_Command;
class ClientRequest_Maintaince;
class ClientRequest_OpenItem;
class ServiceResponse;
class ServiceResponse_Authorization;
class ServiceResponse_FileStatus;
class ServiceResponse_FileStatus_FileInfo;
class ServiceResponse_CopyingStatus;
class ServiceResponse_MaintenanceStatus;
class ServiceResponse_Error;
class ServiceResponse_FileList;
class ServiceResponse_FileList_Item;

enum ClientRequest_MessageType {
  ClientRequest_MessageType_AUTHORIZATION = 1,
  ClientRequest_MessageType_ADDTASK = 2,
  ClientRequest_MessageType_COMMAND = 3,
  ClientRequest_MessageType_MAINTAINCE = 4,
  ClientRequest_MessageType_OPEN_ITEM = 5
};
bool ClientRequest_MessageType_IsValid(int value);
const ClientRequest_MessageType ClientRequest_MessageType_MessageType_MIN = ClientRequest_MessageType_AUTHORIZATION;
const ClientRequest_MessageType ClientRequest_MessageType_MessageType_MAX = ClientRequest_MessageType_OPEN_ITEM;
const int ClientRequest_MessageType_MessageType_ARRAYSIZE = ClientRequest_MessageType_MessageType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ClientRequest_MessageType_descriptor();
inline const ::std::string& ClientRequest_MessageType_Name(ClientRequest_MessageType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ClientRequest_MessageType_descriptor(), value);
}
inline bool ClientRequest_MessageType_Parse(
    const ::std::string& name, ClientRequest_MessageType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ClientRequest_MessageType>(
    ClientRequest_MessageType_descriptor(), name, value);
}
enum ServiceResponse_MessageType {
  ServiceResponse_MessageType_AUTHORIZATION_STATUS = 1,
  ServiceResponse_MessageType_FILE_STATUS = 2,
  ServiceResponse_MessageType_COPYING_STATUS = 3,
  ServiceResponse_MessageType_MAINTENANCE_STATUS = 4,
  ServiceResponse_MessageType_ERRORMESSAGE = 5,
  ServiceResponse_MessageType_FILELIST = 6
};
bool ServiceResponse_MessageType_IsValid(int value);
const ServiceResponse_MessageType ServiceResponse_MessageType_MessageType_MIN = ServiceResponse_MessageType_AUTHORIZATION_STATUS;
const ServiceResponse_MessageType ServiceResponse_MessageType_MessageType_MAX = ServiceResponse_MessageType_FILELIST;
const int ServiceResponse_MessageType_MessageType_ARRAYSIZE = ServiceResponse_MessageType_MessageType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ServiceResponse_MessageType_descriptor();
inline const ::std::string& ServiceResponse_MessageType_Name(ServiceResponse_MessageType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ServiceResponse_MessageType_descriptor(), value);
}
inline bool ServiceResponse_MessageType_Parse(
    const ::std::string& name, ServiceResponse_MessageType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ServiceResponse_MessageType>(
    ServiceResponse_MessageType_descriptor(), name, value);
}
enum FileType {
  VideoTrack = 1,
  RoadNotes = 2,
  Filter = 3,
  Other = 4
};
bool FileType_IsValid(int value);
const FileType FileType_MIN = VideoTrack;
const FileType FileType_MAX = Other;
const int FileType_ARRAYSIZE = FileType_MAX + 1;

const ::google::protobuf::EnumDescriptor* FileType_descriptor();
inline const ::std::string& FileType_Name(FileType value) {
  return ::google::protobuf::internal::NameOfEnum(
    FileType_descriptor(), value);
}
inline bool FileType_Parse(
    const ::std::string& name, FileType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FileType>(
    FileType_descriptor(), name, value);
}
enum CommandType {
  StartUploading = 1,
  Cancel = 2,
  Pause = 3,
  ChangeOption = 4,
  Retry = 5,
  FolderStructureErrorIgnore = 6,
  FolderStructureErrorRetry = 7,
  FolderStructureErrorCancel = 8
};
bool CommandType_IsValid(int value);
const CommandType CommandType_MIN = StartUploading;
const CommandType CommandType_MAX = FolderStructureErrorCancel;
const int CommandType_ARRAYSIZE = CommandType_MAX + 1;

const ::google::protobuf::EnumDescriptor* CommandType_descriptor();
inline const ::std::string& CommandType_Name(CommandType value) {
  return ::google::protobuf::internal::NameOfEnum(
    CommandType_descriptor(), value);
}
inline bool CommandType_Parse(
    const ::std::string& name, CommandType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CommandType>(
    CommandType_descriptor(), name, value);
}
enum TaskStatus {
  Pending = 1,
  Processing = 2,
  Copying = 3,
  Uploading = 4,
  Paused = 5,
  Retrying = 6,
  Error = 7,
  Ok = 8,
  Canceled = 9
};
bool TaskStatus_IsValid(int value);
const TaskStatus TaskStatus_MIN = Pending;
const TaskStatus TaskStatus_MAX = Canceled;
const int TaskStatus_ARRAYSIZE = TaskStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* TaskStatus_descriptor();
inline const ::std::string& TaskStatus_Name(TaskStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    TaskStatus_descriptor(), value);
}
inline bool TaskStatus_Parse(
    const ::std::string& name, TaskStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TaskStatus>(
    TaskStatus_descriptor(), name, value);
}
enum InfoType {
  Progress = 1,
  Archive = 2
};
bool InfoType_IsValid(int value);
const InfoType InfoType_MIN = Progress;
const InfoType InfoType_MAX = Archive;
const int InfoType_ARRAYSIZE = InfoType_MAX + 1;

const ::google::protobuf::EnumDescriptor* InfoType_descriptor();
inline const ::std::string& InfoType_Name(InfoType value) {
  return ::google::protobuf::internal::NameOfEnum(
    InfoType_descriptor(), value);
}
inline bool InfoType_Parse(
    const ::std::string& name, InfoType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<InfoType>(
    InfoType_descriptor(), name, value);
}
enum RequestType {
  GiveMeArchive = 1,
  SendEmail = 2,
  MoveToArchive = 3,
  FileList = 4
};
bool RequestType_IsValid(int value);
const RequestType RequestType_MIN = GiveMeArchive;
const RequestType RequestType_MAX = FileList;
const int RequestType_ARRAYSIZE = RequestType_MAX + 1;

const ::google::protobuf::EnumDescriptor* RequestType_descriptor();
inline const ::std::string& RequestType_Name(RequestType value) {
  return ::google::protobuf::internal::NameOfEnum(
    RequestType_descriptor(), value);
}
inline bool RequestType_Parse(
    const ::std::string& name, RequestType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RequestType>(
    RequestType_descriptor(), name, value);
}
enum ErrorType {
  FolderStructureInvalid = 1
};
bool ErrorType_IsValid(int value);
const ErrorType ErrorType_MIN = FolderStructureInvalid;
const ErrorType ErrorType_MAX = FolderStructureInvalid;
const int ErrorType_ARRAYSIZE = ErrorType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ErrorType_descriptor();
inline const ::std::string& ErrorType_Name(ErrorType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ErrorType_descriptor(), value);
}
inline bool ErrorType_Parse(
    const ::std::string& name, ErrorType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ErrorType>(
    ErrorType_descriptor(), name, value);
}
// ===================================================================

class ClientRequest_Authorization : public ::google::protobuf::Message {
 public:
  ClientRequest_Authorization();
  virtual ~ClientRequest_Authorization();

  ClientRequest_Authorization(const ClientRequest_Authorization& from);

  inline ClientRequest_Authorization& operator=(const ClientRequest_Authorization& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientRequest_Authorization& default_instance();

  void Swap(ClientRequest_Authorization* other);

  // implements Message ----------------------------------------------

  ClientRequest_Authorization* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientRequest_Authorization& from);
  void MergeFrom(const ClientRequest_Authorization& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string login = 1;
  inline bool has_login() const;
  inline void clear_login();
  static const int kLoginFieldNumber = 1;
  inline const ::std::string& login() const;
  inline void set_login(const ::std::string& value);
  inline void set_login(const char* value);
  inline void set_login(const char* value, size_t size);
  inline ::std::string* mutable_login();
  inline ::std::string* release_login();
  inline void set_allocated_login(::std::string* login);

  // required string passwordHash = 2;
  inline bool has_passwordhash() const;
  inline void clear_passwordhash();
  static const int kPasswordHashFieldNumber = 2;
  inline const ::std::string& passwordhash() const;
  inline void set_passwordhash(const ::std::string& value);
  inline void set_passwordhash(const char* value);
  inline void set_passwordhash(const char* value, size_t size);
  inline ::std::string* mutable_passwordhash();
  inline ::std::string* release_passwordhash();
  inline void set_allocated_passwordhash(::std::string* passwordhash);

  // required string host = 3;
  inline bool has_host() const;
  inline void clear_host();
  static const int kHostFieldNumber = 3;
  inline const ::std::string& host() const;
  inline void set_host(const ::std::string& value);
  inline void set_host(const char* value);
  inline void set_host(const char* value, size_t size);
  inline ::std::string* mutable_host();
  inline ::std::string* release_host();
  inline void set_allocated_host(::std::string* host);

  // required uint32 port = 4;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 4;
  inline ::google::protobuf::uint32 port() const;
  inline void set_port(::google::protobuf::uint32 value);

  // optional bool terminateUser = 5;
  inline bool has_terminateuser() const;
  inline void clear_terminateuser();
  static const int kTerminateUserFieldNumber = 5;
  inline bool terminateuser() const;
  inline void set_terminateuser(bool value);

  // @@protoc_insertion_point(class_scope:uploadercontrol.ClientRequest.Authorization)
 private:
  inline void set_has_login();
  inline void clear_has_login();
  inline void set_has_passwordhash();
  inline void clear_has_passwordhash();
  inline void set_has_host();
  inline void clear_has_host();
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_terminateuser();
  inline void clear_has_terminateuser();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* login_;
  ::std::string* passwordhash_;
  ::std::string* host_;
  ::google::protobuf::uint32 port_;
  bool terminateuser_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_remoteclient_2eproto();
  friend void protobuf_AssignDesc_remoteclient_2eproto();
  friend void protobuf_ShutdownFile_remoteclient_2eproto();

  void InitAsDefaultInstance();
  static ClientRequest_Authorization* default_instance_;
};
// -------------------------------------------------------------------

class ClientRequest_AddTask_File : public ::google::protobuf::Message {
 public:
  ClientRequest_AddTask_File();
  virtual ~ClientRequest_AddTask_File();

  ClientRequest_AddTask_File(const ClientRequest_AddTask_File& from);

  inline ClientRequest_AddTask_File& operator=(const ClientRequest_AddTask_File& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientRequest_AddTask_File& default_instance();

  void Swap(ClientRequest_AddTask_File* other);

  // implements Message ----------------------------------------------

  ClientRequest_AddTask_File* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientRequest_AddTask_File& from);
  void MergeFrom(const ClientRequest_AddTask_File& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string pathName = 2;
  inline bool has_pathname() const;
  inline void clear_pathname();
  static const int kPathNameFieldNumber = 2;
  inline const ::std::string& pathname() const;
  inline void set_pathname(const ::std::string& value);
  inline void set_pathname(const char* value);
  inline void set_pathname(const char* value, size_t size);
  inline ::std::string* mutable_pathname();
  inline ::std::string* release_pathname();
  inline void set_allocated_pathname(::std::string* pathname);

  // required .uploadercontrol.FileType filetype = 3;
  inline bool has_filetype() const;
  inline void clear_filetype();
  static const int kFiletypeFieldNumber = 3;
  inline ::uploadercontrol::FileType filetype() const;
  inline void set_filetype(::uploadercontrol::FileType value);

  // required bool isBackup = 4;
  inline bool has_isbackup() const;
  inline void clear_isbackup();
  static const int kIsBackupFieldNumber = 4;
  inline bool isbackup() const;
  inline void set_isbackup(bool value);

  // @@protoc_insertion_point(class_scope:uploadercontrol.ClientRequest.AddTask.File)
 private:
  inline void set_has_pathname();
  inline void clear_has_pathname();
  inline void set_has_filetype();
  inline void clear_has_filetype();
  inline void set_has_isbackup();
  inline void clear_has_isbackup();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* pathname_;
  int filetype_;
  bool isbackup_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_remoteclient_2eproto();
  friend void protobuf_AssignDesc_remoteclient_2eproto();
  friend void protobuf_ShutdownFile_remoteclient_2eproto();

  void InitAsDefaultInstance();
  static ClientRequest_AddTask_File* default_instance_;
};
// -------------------------------------------------------------------

class ClientRequest_AddTask : public ::google::protobuf::Message {
 public:
  ClientRequest_AddTask();
  virtual ~ClientRequest_AddTask();

  ClientRequest_AddTask(const ClientRequest_AddTask& from);

  inline ClientRequest_AddTask& operator=(const ClientRequest_AddTask& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientRequest_AddTask& default_instance();

  void Swap(ClientRequest_AddTask* other);

  // implements Message ----------------------------------------------

  ClientRequest_AddTask* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientRequest_AddTask& from);
  void MergeFrom(const ClientRequest_AddTask& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ClientRequest_AddTask_File File;

  // accessors -------------------------------------------------------

  // required string taskName = 1;
  inline bool has_taskname() const;
  inline void clear_taskname();
  static const int kTaskNameFieldNumber = 1;
  inline const ::std::string& taskname() const;
  inline void set_taskname(const ::std::string& value);
  inline void set_taskname(const char* value);
  inline void set_taskname(const char* value, size_t size);
  inline ::std::string* mutable_taskname();
  inline ::std::string* release_taskname();
  inline void set_allocated_taskname(::std::string* taskname);

  // repeated .uploadercontrol.ClientRequest.AddTask.File files = 2;
  inline int files_size() const;
  inline void clear_files();
  static const int kFilesFieldNumber = 2;
  inline const ::uploadercontrol::ClientRequest_AddTask_File& files(int index) const;
  inline ::uploadercontrol::ClientRequest_AddTask_File* mutable_files(int index);
  inline ::uploadercontrol::ClientRequest_AddTask_File* add_files();
  inline const ::google::protobuf::RepeatedPtrField< ::uploadercontrol::ClientRequest_AddTask_File >&
      files() const;
  inline ::google::protobuf::RepeatedPtrField< ::uploadercontrol::ClientRequest_AddTask_File >*
      mutable_files();

  // required bool doCopy = 3;
  inline bool has_docopy() const;
  inline void clear_docopy();
  static const int kDoCopyFieldNumber = 3;
  inline bool docopy() const;
  inline void set_docopy(bool value);

  // required bool removeSourceFiles = 4;
  inline bool has_removesourcefiles() const;
  inline void clear_removesourcefiles();
  static const int kRemoveSourceFilesFieldNumber = 4;
  inline bool removesourcefiles() const;
  inline void set_removesourcefiles(bool value);

  // required bool index = 5;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 5;
  inline bool index() const;
  inline void set_index(bool value);

  // @@protoc_insertion_point(class_scope:uploadercontrol.ClientRequest.AddTask)
 private:
  inline void set_has_taskname();
  inline void clear_has_taskname();
  inline void set_has_docopy();
  inline void clear_has_docopy();
  inline void set_has_removesourcefiles();
  inline void clear_has_removesourcefiles();
  inline void set_has_index();
  inline void clear_has_index();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* taskname_;
  ::google::protobuf::RepeatedPtrField< ::uploadercontrol::ClientRequest_AddTask_File > files_;
  bool docopy_;
  bool removesourcefiles_;
  bool index_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_remoteclient_2eproto();
  friend void protobuf_AssignDesc_remoteclient_2eproto();
  friend void protobuf_ShutdownFile_remoteclient_2eproto();

  void InitAsDefaultInstance();
  static ClientRequest_AddTask* default_instance_;
};
// -------------------------------------------------------------------

class ClientRequest_Command : public ::google::protobuf::Message {
 public:
  ClientRequest_Command();
  virtual ~ClientRequest_Command();

  ClientRequest_Command(const ClientRequest_Command& from);

  inline ClientRequest_Command& operator=(const ClientRequest_Command& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientRequest_Command& default_instance();

  void Swap(ClientRequest_Command* other);

  // implements Message ----------------------------------------------

  ClientRequest_Command* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientRequest_Command& from);
  void MergeFrom(const ClientRequest_Command& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string checkSum = 1;
  inline bool has_checksum() const;
  inline void clear_checksum();
  static const int kCheckSumFieldNumber = 1;
  inline const ::std::string& checksum() const;
  inline void set_checksum(const ::std::string& value);
  inline void set_checksum(const char* value);
  inline void set_checksum(const char* value, size_t size);
  inline ::std::string* mutable_checksum();
  inline ::std::string* release_checksum();
  inline void set_allocated_checksum(::std::string* checksum);

  // optional bool isBackup = 2;
  inline bool has_isbackup() const;
  inline void clear_isbackup();
  static const int kIsBackupFieldNumber = 2;
  inline bool isbackup() const;
  inline void set_isbackup(bool value);

  // required .uploadercontrol.CommandType commandType = 3;
  inline bool has_commandtype() const;
  inline void clear_commandtype();
  static const int kCommandTypeFieldNumber = 3;
  inline ::uploadercontrol::CommandType commandtype() const;
  inline void set_commandtype(::uploadercontrol::CommandType value);

  // @@protoc_insertion_point(class_scope:uploadercontrol.ClientRequest.Command)
 private:
  inline void set_has_checksum();
  inline void clear_has_checksum();
  inline void set_has_isbackup();
  inline void clear_has_isbackup();
  inline void set_has_commandtype();
  inline void clear_has_commandtype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* checksum_;
  bool isbackup_;
  int commandtype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_remoteclient_2eproto();
  friend void protobuf_AssignDesc_remoteclient_2eproto();
  friend void protobuf_ShutdownFile_remoteclient_2eproto();

  void InitAsDefaultInstance();
  static ClientRequest_Command* default_instance_;
};
// -------------------------------------------------------------------

class ClientRequest_Maintaince : public ::google::protobuf::Message {
 public:
  ClientRequest_Maintaince();
  virtual ~ClientRequest_Maintaince();

  ClientRequest_Maintaince(const ClientRequest_Maintaince& from);

  inline ClientRequest_Maintaince& operator=(const ClientRequest_Maintaince& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientRequest_Maintaince& default_instance();

  void Swap(ClientRequest_Maintaince* other);

  // implements Message ----------------------------------------------

  ClientRequest_Maintaince* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientRequest_Maintaince& from);
  void MergeFrom(const ClientRequest_Maintaince& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .uploadercontrol.RequestType requestType = 1;
  inline bool has_requesttype() const;
  inline void clear_requesttype();
  static const int kRequestTypeFieldNumber = 1;
  inline ::uploadercontrol::RequestType requesttype() const;
  inline void set_requesttype(::uploadercontrol::RequestType value);

  // optional string login = 2;
  inline bool has_login() const;
  inline void clear_login();
  static const int kLoginFieldNumber = 2;
  inline const ::std::string& login() const;
  inline void set_login(const ::std::string& value);
  inline void set_login(const char* value);
  inline void set_login(const char* value, size_t size);
  inline ::std::string* mutable_login();
  inline ::std::string* release_login();
  inline void set_allocated_login(::std::string* login);

  // optional bool removeSourceFiles = 3;
  inline bool has_removesourcefiles() const;
  inline void clear_removesourcefiles();
  static const int kRemoveSourceFilesFieldNumber = 3;
  inline bool removesourcefiles() const;
  inline void set_removesourcefiles(bool value);

  // @@protoc_insertion_point(class_scope:uploadercontrol.ClientRequest.Maintaince)
 private:
  inline void set_has_requesttype();
  inline void clear_has_requesttype();
  inline void set_has_login();
  inline void clear_has_login();
  inline void set_has_removesourcefiles();
  inline void clear_has_removesourcefiles();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* login_;
  int requesttype_;
  bool removesourcefiles_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_remoteclient_2eproto();
  friend void protobuf_AssignDesc_remoteclient_2eproto();
  friend void protobuf_ShutdownFile_remoteclient_2eproto();

  void InitAsDefaultInstance();
  static ClientRequest_Maintaince* default_instance_;
};
// -------------------------------------------------------------------

class ClientRequest_OpenItem : public ::google::protobuf::Message {
 public:
  ClientRequest_OpenItem();
  virtual ~ClientRequest_OpenItem();

  ClientRequest_OpenItem(const ClientRequest_OpenItem& from);

  inline ClientRequest_OpenItem& operator=(const ClientRequest_OpenItem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientRequest_OpenItem& default_instance();

  void Swap(ClientRequest_OpenItem* other);

  // implements Message ----------------------------------------------

  ClientRequest_OpenItem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientRequest_OpenItem& from);
  void MergeFrom(const ClientRequest_OpenItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string item = 1;
  inline bool has_item() const;
  inline void clear_item();
  static const int kItemFieldNumber = 1;
  inline const ::std::string& item() const;
  inline void set_item(const ::std::string& value);
  inline void set_item(const char* value);
  inline void set_item(const char* value, size_t size);
  inline ::std::string* mutable_item();
  inline ::std::string* release_item();
  inline void set_allocated_item(::std::string* item);

  // required bool listRecursively = 2;
  inline bool has_listrecursively() const;
  inline void clear_listrecursively();
  static const int kListRecursivelyFieldNumber = 2;
  inline bool listrecursively() const;
  inline void set_listrecursively(bool value);

  // @@protoc_insertion_point(class_scope:uploadercontrol.ClientRequest.OpenItem)
 private:
  inline void set_has_item();
  inline void clear_has_item();
  inline void set_has_listrecursively();
  inline void clear_has_listrecursively();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* item_;
  bool listrecursively_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_remoteclient_2eproto();
  friend void protobuf_AssignDesc_remoteclient_2eproto();
  friend void protobuf_ShutdownFile_remoteclient_2eproto();

  void InitAsDefaultInstance();
  static ClientRequest_OpenItem* default_instance_;
};
// -------------------------------------------------------------------

class ClientRequest : public ::google::protobuf::Message {
 public:
  ClientRequest();
  virtual ~ClientRequest();

  ClientRequest(const ClientRequest& from);

  inline ClientRequest& operator=(const ClientRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientRequest& default_instance();

  void Swap(ClientRequest* other);

  // implements Message ----------------------------------------------

  ClientRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientRequest& from);
  void MergeFrom(const ClientRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ClientRequest_Authorization Authorization;
  typedef ClientRequest_AddTask AddTask;
  typedef ClientRequest_Command Command;
  typedef ClientRequest_Maintaince Maintaince;
  typedef ClientRequest_OpenItem OpenItem;

  typedef ClientRequest_MessageType MessageType;
  static const MessageType AUTHORIZATION = ClientRequest_MessageType_AUTHORIZATION;
  static const MessageType ADDTASK = ClientRequest_MessageType_ADDTASK;
  static const MessageType COMMAND = ClientRequest_MessageType_COMMAND;
  static const MessageType MAINTAINCE = ClientRequest_MessageType_MAINTAINCE;
  static const MessageType OPEN_ITEM = ClientRequest_MessageType_OPEN_ITEM;
  static inline bool MessageType_IsValid(int value) {
    return ClientRequest_MessageType_IsValid(value);
  }
  static const MessageType MessageType_MIN =
    ClientRequest_MessageType_MessageType_MIN;
  static const MessageType MessageType_MAX =
    ClientRequest_MessageType_MessageType_MAX;
  static const int MessageType_ARRAYSIZE =
    ClientRequest_MessageType_MessageType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  MessageType_descriptor() {
    return ClientRequest_MessageType_descriptor();
  }
  static inline const ::std::string& MessageType_Name(MessageType value) {
    return ClientRequest_MessageType_Name(value);
  }
  static inline bool MessageType_Parse(const ::std::string& name,
      MessageType* value) {
    return ClientRequest_MessageType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .uploadercontrol.ClientRequest.MessageType messageType = 1;
  inline bool has_messagetype() const;
  inline void clear_messagetype();
  static const int kMessageTypeFieldNumber = 1;
  inline ::uploadercontrol::ClientRequest_MessageType messagetype() const;
  inline void set_messagetype(::uploadercontrol::ClientRequest_MessageType value);

  // optional .uploadercontrol.ClientRequest.Authorization authorization = 2;
  inline bool has_authorization() const;
  inline void clear_authorization();
  static const int kAuthorizationFieldNumber = 2;
  inline const ::uploadercontrol::ClientRequest_Authorization& authorization() const;
  inline ::uploadercontrol::ClientRequest_Authorization* mutable_authorization();
  inline ::uploadercontrol::ClientRequest_Authorization* release_authorization();
  inline void set_allocated_authorization(::uploadercontrol::ClientRequest_Authorization* authorization);

  // optional .uploadercontrol.ClientRequest.AddTask addTask = 3;
  inline bool has_addtask() const;
  inline void clear_addtask();
  static const int kAddTaskFieldNumber = 3;
  inline const ::uploadercontrol::ClientRequest_AddTask& addtask() const;
  inline ::uploadercontrol::ClientRequest_AddTask* mutable_addtask();
  inline ::uploadercontrol::ClientRequest_AddTask* release_addtask();
  inline void set_allocated_addtask(::uploadercontrol::ClientRequest_AddTask* addtask);

  // optional .uploadercontrol.ClientRequest.Command command = 4;
  inline bool has_command() const;
  inline void clear_command();
  static const int kCommandFieldNumber = 4;
  inline const ::uploadercontrol::ClientRequest_Command& command() const;
  inline ::uploadercontrol::ClientRequest_Command* mutable_command();
  inline ::uploadercontrol::ClientRequest_Command* release_command();
  inline void set_allocated_command(::uploadercontrol::ClientRequest_Command* command);

  // optional .uploadercontrol.ClientRequest.Maintaince maintaince = 5;
  inline bool has_maintaince() const;
  inline void clear_maintaince();
  static const int kMaintainceFieldNumber = 5;
  inline const ::uploadercontrol::ClientRequest_Maintaince& maintaince() const;
  inline ::uploadercontrol::ClientRequest_Maintaince* mutable_maintaince();
  inline ::uploadercontrol::ClientRequest_Maintaince* release_maintaince();
  inline void set_allocated_maintaince(::uploadercontrol::ClientRequest_Maintaince* maintaince);

  // optional .uploadercontrol.ClientRequest.OpenItem openItem = 6;
  inline bool has_openitem() const;
  inline void clear_openitem();
  static const int kOpenItemFieldNumber = 6;
  inline const ::uploadercontrol::ClientRequest_OpenItem& openitem() const;
  inline ::uploadercontrol::ClientRequest_OpenItem* mutable_openitem();
  inline ::uploadercontrol::ClientRequest_OpenItem* release_openitem();
  inline void set_allocated_openitem(::uploadercontrol::ClientRequest_OpenItem* openitem);

  // @@protoc_insertion_point(class_scope:uploadercontrol.ClientRequest)
 private:
  inline void set_has_messagetype();
  inline void clear_has_messagetype();
  inline void set_has_authorization();
  inline void clear_has_authorization();
  inline void set_has_addtask();
  inline void clear_has_addtask();
  inline void set_has_command();
  inline void clear_has_command();
  inline void set_has_maintaince();
  inline void clear_has_maintaince();
  inline void set_has_openitem();
  inline void clear_has_openitem();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::uploadercontrol::ClientRequest_Authorization* authorization_;
  ::uploadercontrol::ClientRequest_AddTask* addtask_;
  ::uploadercontrol::ClientRequest_Command* command_;
  ::uploadercontrol::ClientRequest_Maintaince* maintaince_;
  ::uploadercontrol::ClientRequest_OpenItem* openitem_;
  int messagetype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_remoteclient_2eproto();
  friend void protobuf_AssignDesc_remoteclient_2eproto();
  friend void protobuf_ShutdownFile_remoteclient_2eproto();

  void InitAsDefaultInstance();
  static ClientRequest* default_instance_;
};
// -------------------------------------------------------------------

class ServiceResponse_Authorization : public ::google::protobuf::Message {
 public:
  ServiceResponse_Authorization();
  virtual ~ServiceResponse_Authorization();

  ServiceResponse_Authorization(const ServiceResponse_Authorization& from);

  inline ServiceResponse_Authorization& operator=(const ServiceResponse_Authorization& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServiceResponse_Authorization& default_instance();

  void Swap(ServiceResponse_Authorization* other);

  // implements Message ----------------------------------------------

  ServiceResponse_Authorization* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ServiceResponse_Authorization& from);
  void MergeFrom(const ServiceResponse_Authorization& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool isOk = 1 [default = false];
  inline bool has_isok() const;
  inline void clear_isok();
  static const int kIsOkFieldNumber = 1;
  inline bool isok() const;
  inline void set_isok(bool value);

  // required bool isAdmin = 2;
  inline bool has_isadmin() const;
  inline void clear_isadmin();
  static const int kIsAdminFieldNumber = 2;
  inline bool isadmin() const;
  inline void set_isadmin(bool value);

  // required bool alreadyAuthorized = 3;
  inline bool has_alreadyauthorized() const;
  inline void clear_alreadyauthorized();
  static const int kAlreadyAuthorizedFieldNumber = 3;
  inline bool alreadyauthorized() const;
  inline void set_alreadyauthorized(bool value);

  // @@protoc_insertion_point(class_scope:uploadercontrol.ServiceResponse.Authorization)
 private:
  inline void set_has_isok();
  inline void clear_has_isok();
  inline void set_has_isadmin();
  inline void clear_has_isadmin();
  inline void set_has_alreadyauthorized();
  inline void clear_has_alreadyauthorized();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool isok_;
  bool isadmin_;
  bool alreadyauthorized_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_remoteclient_2eproto();
  friend void protobuf_AssignDesc_remoteclient_2eproto();
  friend void protobuf_ShutdownFile_remoteclient_2eproto();

  void InitAsDefaultInstance();
  static ServiceResponse_Authorization* default_instance_;
};
// -------------------------------------------------------------------

class ServiceResponse_FileStatus_FileInfo : public ::google::protobuf::Message {
 public:
  ServiceResponse_FileStatus_FileInfo();
  virtual ~ServiceResponse_FileStatus_FileInfo();

  ServiceResponse_FileStatus_FileInfo(const ServiceResponse_FileStatus_FileInfo& from);

  inline ServiceResponse_FileStatus_FileInfo& operator=(const ServiceResponse_FileStatus_FileInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServiceResponse_FileStatus_FileInfo& default_instance();

  void Swap(ServiceResponse_FileStatus_FileInfo* other);

  // implements Message ----------------------------------------------

  ServiceResponse_FileStatus_FileInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ServiceResponse_FileStatus_FileInfo& from);
  void MergeFrom(const ServiceResponse_FileStatus_FileInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string task = 1;
  inline bool has_task() const;
  inline void clear_task();
  static const int kTaskFieldNumber = 1;
  inline const ::std::string& task() const;
  inline void set_task(const ::std::string& value);
  inline void set_task(const char* value);
  inline void set_task(const char* value, size_t size);
  inline ::std::string* mutable_task();
  inline ::std::string* release_task();
  inline void set_allocated_task(::std::string* task);

  // required string pathName = 2;
  inline bool has_pathname() const;
  inline void clear_pathname();
  static const int kPathNameFieldNumber = 2;
  inline const ::std::string& pathname() const;
  inline void set_pathname(const ::std::string& value);
  inline void set_pathname(const char* value);
  inline void set_pathname(const char* value, size_t size);
  inline ::std::string* mutable_pathname();
  inline ::std::string* release_pathname();
  inline void set_allocated_pathname(::std::string* pathname);

  // required .uploadercontrol.TaskStatus status = 3;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 3;
  inline ::uploadercontrol::TaskStatus status() const;
  inline void set_status(::uploadercontrol::TaskStatus value);

  // optional string fileId = 4;
  inline bool has_fileid() const;
  inline void clear_fileid();
  static const int kFileIdFieldNumber = 4;
  inline const ::std::string& fileid() const;
  inline void set_fileid(const ::std::string& value);
  inline void set_fileid(const char* value);
  inline void set_fileid(const char* value, size_t size);
  inline ::std::string* mutable_fileid();
  inline ::std::string* release_fileid();
  inline void set_allocated_fileid(::std::string* fileid);

  // required uint64 size = 5;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 5;
  inline ::google::protobuf::uint64 size() const;
  inline void set_size(::google::protobuf::uint64 value);

  // required bool isBackup = 6;
  inline bool has_isbackup() const;
  inline void clear_isbackup();
  static const int kIsBackupFieldNumber = 6;
  inline bool isbackup() const;
  inline void set_isbackup(bool value);

  // required bytes checkSum = 7;
  inline bool has_checksum() const;
  inline void clear_checksum();
  static const int kCheckSumFieldNumber = 7;
  inline const ::std::string& checksum() const;
  inline void set_checksum(const ::std::string& value);
  inline void set_checksum(const char* value);
  inline void set_checksum(const void* value, size_t size);
  inline ::std::string* mutable_checksum();
  inline ::std::string* release_checksum();
  inline void set_allocated_checksum(::std::string* checksum);

  // required uint32 retriesCount = 8;
  inline bool has_retriescount() const;
  inline void clear_retriescount();
  static const int kRetriesCountFieldNumber = 8;
  inline ::google::protobuf::uint32 retriescount() const;
  inline void set_retriescount(::google::protobuf::uint32 value);

  // optional uint64 bytesProcessed = 9;
  inline bool has_bytesprocessed() const;
  inline void clear_bytesprocessed();
  static const int kBytesProcessedFieldNumber = 9;
  inline ::google::protobuf::uint64 bytesprocessed() const;
  inline void set_bytesprocessed(::google::protobuf::uint64 value);

  // optional string additionalMessage = 10;
  inline bool has_additionalmessage() const;
  inline void clear_additionalmessage();
  static const int kAdditionalMessageFieldNumber = 10;
  inline const ::std::string& additionalmessage() const;
  inline void set_additionalmessage(const ::std::string& value);
  inline void set_additionalmessage(const char* value);
  inline void set_additionalmessage(const char* value, size_t size);
  inline ::std::string* mutable_additionalmessage();
  inline ::std::string* release_additionalmessage();
  inline void set_allocated_additionalmessage(::std::string* additionalmessage);

  // optional uint64 uploadDate = 11;
  inline bool has_uploaddate() const;
  inline void clear_uploaddate();
  static const int kUploadDateFieldNumber = 11;
  inline ::google::protobuf::uint64 uploaddate() const;
  inline void set_uploaddate(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:uploadercontrol.ServiceResponse.FileStatus.FileInfo)
 private:
  inline void set_has_task();
  inline void clear_has_task();
  inline void set_has_pathname();
  inline void clear_has_pathname();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_fileid();
  inline void clear_has_fileid();
  inline void set_has_size();
  inline void clear_has_size();
  inline void set_has_isbackup();
  inline void clear_has_isbackup();
  inline void set_has_checksum();
  inline void clear_has_checksum();
  inline void set_has_retriescount();
  inline void clear_has_retriescount();
  inline void set_has_bytesprocessed();
  inline void clear_has_bytesprocessed();
  inline void set_has_additionalmessage();
  inline void clear_has_additionalmessage();
  inline void set_has_uploaddate();
  inline void clear_has_uploaddate();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* task_;
  ::std::string* pathname_;
  ::std::string* fileid_;
  int status_;
  bool isbackup_;
  ::google::protobuf::uint64 size_;
  ::std::string* checksum_;
  ::google::protobuf::uint64 bytesprocessed_;
  ::std::string* additionalmessage_;
  ::google::protobuf::uint64 uploaddate_;
  ::google::protobuf::uint32 retriescount_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  friend void  protobuf_AddDesc_remoteclient_2eproto();
  friend void protobuf_AssignDesc_remoteclient_2eproto();
  friend void protobuf_ShutdownFile_remoteclient_2eproto();

  void InitAsDefaultInstance();
  static ServiceResponse_FileStatus_FileInfo* default_instance_;
};
// -------------------------------------------------------------------

class ServiceResponse_FileStatus : public ::google::protobuf::Message {
 public:
  ServiceResponse_FileStatus();
  virtual ~ServiceResponse_FileStatus();

  ServiceResponse_FileStatus(const ServiceResponse_FileStatus& from);

  inline ServiceResponse_FileStatus& operator=(const ServiceResponse_FileStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServiceResponse_FileStatus& default_instance();

  void Swap(ServiceResponse_FileStatus* other);

  // implements Message ----------------------------------------------

  ServiceResponse_FileStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ServiceResponse_FileStatus& from);
  void MergeFrom(const ServiceResponse_FileStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ServiceResponse_FileStatus_FileInfo FileInfo;

  // accessors -------------------------------------------------------

  // required .uploadercontrol.InfoType responseType = 1;
  inline bool has_responsetype() const;
  inline void clear_responsetype();
  static const int kResponseTypeFieldNumber = 1;
  inline ::uploadercontrol::InfoType responsetype() const;
  inline void set_responsetype(::uploadercontrol::InfoType value);

  // optional string login = 2;
  inline bool has_login() const;
  inline void clear_login();
  static const int kLoginFieldNumber = 2;
  inline const ::std::string& login() const;
  inline void set_login(const ::std::string& value);
  inline void set_login(const char* value);
  inline void set_login(const char* value, size_t size);
  inline ::std::string* mutable_login();
  inline ::std::string* release_login();
  inline void set_allocated_login(::std::string* login);

  // repeated .uploadercontrol.ServiceResponse.FileStatus.FileInfo infos = 3;
  inline int infos_size() const;
  inline void clear_infos();
  static const int kInfosFieldNumber = 3;
  inline const ::uploadercontrol::ServiceResponse_FileStatus_FileInfo& infos(int index) const;
  inline ::uploadercontrol::ServiceResponse_FileStatus_FileInfo* mutable_infos(int index);
  inline ::uploadercontrol::ServiceResponse_FileStatus_FileInfo* add_infos();
  inline const ::google::protobuf::RepeatedPtrField< ::uploadercontrol::ServiceResponse_FileStatus_FileInfo >&
      infos() const;
  inline ::google::protobuf::RepeatedPtrField< ::uploadercontrol::ServiceResponse_FileStatus_FileInfo >*
      mutable_infos();

  // @@protoc_insertion_point(class_scope:uploadercontrol.ServiceResponse.FileStatus)
 private:
  inline void set_has_responsetype();
  inline void clear_has_responsetype();
  inline void set_has_login();
  inline void clear_has_login();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* login_;
  ::google::protobuf::RepeatedPtrField< ::uploadercontrol::ServiceResponse_FileStatus_FileInfo > infos_;
  int responsetype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_remoteclient_2eproto();
  friend void protobuf_AssignDesc_remoteclient_2eproto();
  friend void protobuf_ShutdownFile_remoteclient_2eproto();

  void InitAsDefaultInstance();
  static ServiceResponse_FileStatus* default_instance_;
};
// -------------------------------------------------------------------

class ServiceResponse_CopyingStatus : public ::google::protobuf::Message {
 public:
  ServiceResponse_CopyingStatus();
  virtual ~ServiceResponse_CopyingStatus();

  ServiceResponse_CopyingStatus(const ServiceResponse_CopyingStatus& from);

  inline ServiceResponse_CopyingStatus& operator=(const ServiceResponse_CopyingStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServiceResponse_CopyingStatus& default_instance();

  void Swap(ServiceResponse_CopyingStatus* other);

  // implements Message ----------------------------------------------

  ServiceResponse_CopyingStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ServiceResponse_CopyingStatus& from);
  void MergeFrom(const ServiceResponse_CopyingStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 filesTotal = 1;
  inline bool has_filestotal() const;
  inline void clear_filestotal();
  static const int kFilesTotalFieldNumber = 1;
  inline ::google::protobuf::uint32 filestotal() const;
  inline void set_filestotal(::google::protobuf::uint32 value);

  // required uint32 filesCopied = 2;
  inline bool has_filescopied() const;
  inline void clear_filescopied();
  static const int kFilesCopiedFieldNumber = 2;
  inline ::google::protobuf::uint32 filescopied() const;
  inline void set_filescopied(::google::protobuf::uint32 value);

  // optional string login = 3;
  inline bool has_login() const;
  inline void clear_login();
  static const int kLoginFieldNumber = 3;
  inline const ::std::string& login() const;
  inline void set_login(const ::std::string& value);
  inline void set_login(const char* value);
  inline void set_login(const char* value, size_t size);
  inline ::std::string* mutable_login();
  inline ::std::string* release_login();
  inline void set_allocated_login(::std::string* login);

  // @@protoc_insertion_point(class_scope:uploadercontrol.ServiceResponse.CopyingStatus)
 private:
  inline void set_has_filestotal();
  inline void clear_has_filestotal();
  inline void set_has_filescopied();
  inline void clear_has_filescopied();
  inline void set_has_login();
  inline void clear_has_login();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 filestotal_;
  ::google::protobuf::uint32 filescopied_;
  ::std::string* login_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_remoteclient_2eproto();
  friend void protobuf_AssignDesc_remoteclient_2eproto();
  friend void protobuf_ShutdownFile_remoteclient_2eproto();

  void InitAsDefaultInstance();
  static ServiceResponse_CopyingStatus* default_instance_;
};
// -------------------------------------------------------------------

class ServiceResponse_MaintenanceStatus : public ::google::protobuf::Message {
 public:
  ServiceResponse_MaintenanceStatus();
  virtual ~ServiceResponse_MaintenanceStatus();

  ServiceResponse_MaintenanceStatus(const ServiceResponse_MaintenanceStatus& from);

  inline ServiceResponse_MaintenanceStatus& operator=(const ServiceResponse_MaintenanceStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServiceResponse_MaintenanceStatus& default_instance();

  void Swap(ServiceResponse_MaintenanceStatus* other);

  // implements Message ----------------------------------------------

  ServiceResponse_MaintenanceStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ServiceResponse_MaintenanceStatus& from);
  void MergeFrom(const ServiceResponse_MaintenanceStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool isPaused = 1;
  inline bool has_ispaused() const;
  inline void clear_ispaused();
  static const int kIsPausedFieldNumber = 1;
  inline bool ispaused() const;
  inline void set_ispaused(bool value);

  // @@protoc_insertion_point(class_scope:uploadercontrol.ServiceResponse.MaintenanceStatus)
 private:
  inline void set_has_ispaused();
  inline void clear_has_ispaused();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool ispaused_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_remoteclient_2eproto();
  friend void protobuf_AssignDesc_remoteclient_2eproto();
  friend void protobuf_ShutdownFile_remoteclient_2eproto();

  void InitAsDefaultInstance();
  static ServiceResponse_MaintenanceStatus* default_instance_;
};
// -------------------------------------------------------------------

class ServiceResponse_Error : public ::google::protobuf::Message {
 public:
  ServiceResponse_Error();
  virtual ~ServiceResponse_Error();

  ServiceResponse_Error(const ServiceResponse_Error& from);

  inline ServiceResponse_Error& operator=(const ServiceResponse_Error& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServiceResponse_Error& default_instance();

  void Swap(ServiceResponse_Error* other);

  // implements Message ----------------------------------------------

  ServiceResponse_Error* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ServiceResponse_Error& from);
  void MergeFrom(const ServiceResponse_Error& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .uploadercontrol.ErrorType error = 1;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 1;
  inline ::uploadercontrol::ErrorType error() const;
  inline void set_error(::uploadercontrol::ErrorType value);

  // required string message = 2;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 2;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const char* value, size_t size);
  inline ::std::string* mutable_message();
  inline ::std::string* release_message();
  inline void set_allocated_message(::std::string* message);

  // @@protoc_insertion_point(class_scope:uploadercontrol.ServiceResponse.Error)
 private:
  inline void set_has_error();
  inline void clear_has_error();
  inline void set_has_message();
  inline void clear_has_message();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* message_;
  int error_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_remoteclient_2eproto();
  friend void protobuf_AssignDesc_remoteclient_2eproto();
  friend void protobuf_ShutdownFile_remoteclient_2eproto();

  void InitAsDefaultInstance();
  static ServiceResponse_Error* default_instance_;
};
// -------------------------------------------------------------------

class ServiceResponse_FileList_Item : public ::google::protobuf::Message {
 public:
  ServiceResponse_FileList_Item();
  virtual ~ServiceResponse_FileList_Item();

  ServiceResponse_FileList_Item(const ServiceResponse_FileList_Item& from);

  inline ServiceResponse_FileList_Item& operator=(const ServiceResponse_FileList_Item& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServiceResponse_FileList_Item& default_instance();

  void Swap(ServiceResponse_FileList_Item* other);

  // implements Message ----------------------------------------------

  ServiceResponse_FileList_Item* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ServiceResponse_FileList_Item& from);
  void MergeFrom(const ServiceResponse_FileList_Item& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool isFolder = 1;
  inline bool has_isfolder() const;
  inline void clear_isfolder();
  static const int kIsFolderFieldNumber = 1;
  inline bool isfolder() const;
  inline void set_isfolder(bool value);

  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:uploadercontrol.ServiceResponse.FileList.Item)
 private:
  inline void set_has_isfolder();
  inline void clear_has_isfolder();
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  bool isfolder_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_remoteclient_2eproto();
  friend void protobuf_AssignDesc_remoteclient_2eproto();
  friend void protobuf_ShutdownFile_remoteclient_2eproto();

  void InitAsDefaultInstance();
  static ServiceResponse_FileList_Item* default_instance_;
};
// -------------------------------------------------------------------

class ServiceResponse_FileList : public ::google::protobuf::Message {
 public:
  ServiceResponse_FileList();
  virtual ~ServiceResponse_FileList();

  ServiceResponse_FileList(const ServiceResponse_FileList& from);

  inline ServiceResponse_FileList& operator=(const ServiceResponse_FileList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServiceResponse_FileList& default_instance();

  void Swap(ServiceResponse_FileList* other);

  // implements Message ----------------------------------------------

  ServiceResponse_FileList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ServiceResponse_FileList& from);
  void MergeFrom(const ServiceResponse_FileList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ServiceResponse_FileList_Item Item;

  // accessors -------------------------------------------------------

  // repeated .uploadercontrol.ServiceResponse.FileList.Item list = 1;
  inline int list_size() const;
  inline void clear_list();
  static const int kListFieldNumber = 1;
  inline const ::uploadercontrol::ServiceResponse_FileList_Item& list(int index) const;
  inline ::uploadercontrol::ServiceResponse_FileList_Item* mutable_list(int index);
  inline ::uploadercontrol::ServiceResponse_FileList_Item* add_list();
  inline const ::google::protobuf::RepeatedPtrField< ::uploadercontrol::ServiceResponse_FileList_Item >&
      list() const;
  inline ::google::protobuf::RepeatedPtrField< ::uploadercontrol::ServiceResponse_FileList_Item >*
      mutable_list();

  // required bool folderContentRecursively = 2;
  inline bool has_foldercontentrecursively() const;
  inline void clear_foldercontentrecursively();
  static const int kFolderContentRecursivelyFieldNumber = 2;
  inline bool foldercontentrecursively() const;
  inline void set_foldercontentrecursively(bool value);

  // @@protoc_insertion_point(class_scope:uploadercontrol.ServiceResponse.FileList)
 private:
  inline void set_has_foldercontentrecursively();
  inline void clear_has_foldercontentrecursively();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::uploadercontrol::ServiceResponse_FileList_Item > list_;
  bool foldercontentrecursively_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_remoteclient_2eproto();
  friend void protobuf_AssignDesc_remoteclient_2eproto();
  friend void protobuf_ShutdownFile_remoteclient_2eproto();

  void InitAsDefaultInstance();
  static ServiceResponse_FileList* default_instance_;
};
// -------------------------------------------------------------------

class ServiceResponse : public ::google::protobuf::Message {
 public:
  ServiceResponse();
  virtual ~ServiceResponse();

  ServiceResponse(const ServiceResponse& from);

  inline ServiceResponse& operator=(const ServiceResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServiceResponse& default_instance();

  void Swap(ServiceResponse* other);

  // implements Message ----------------------------------------------

  ServiceResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ServiceResponse& from);
  void MergeFrom(const ServiceResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ServiceResponse_Authorization Authorization;
  typedef ServiceResponse_FileStatus FileStatus;
  typedef ServiceResponse_CopyingStatus CopyingStatus;
  typedef ServiceResponse_MaintenanceStatus MaintenanceStatus;
  typedef ServiceResponse_Error Error;
  typedef ServiceResponse_FileList FileList;

  typedef ServiceResponse_MessageType MessageType;
  static const MessageType AUTHORIZATION_STATUS = ServiceResponse_MessageType_AUTHORIZATION_STATUS;
  static const MessageType FILE_STATUS = ServiceResponse_MessageType_FILE_STATUS;
  static const MessageType COPYING_STATUS = ServiceResponse_MessageType_COPYING_STATUS;
  static const MessageType MAINTENANCE_STATUS = ServiceResponse_MessageType_MAINTENANCE_STATUS;
  static const MessageType ERRORMESSAGE = ServiceResponse_MessageType_ERRORMESSAGE;
  static const MessageType FILELIST = ServiceResponse_MessageType_FILELIST;
  static inline bool MessageType_IsValid(int value) {
    return ServiceResponse_MessageType_IsValid(value);
  }
  static const MessageType MessageType_MIN =
    ServiceResponse_MessageType_MessageType_MIN;
  static const MessageType MessageType_MAX =
    ServiceResponse_MessageType_MessageType_MAX;
  static const int MessageType_ARRAYSIZE =
    ServiceResponse_MessageType_MessageType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  MessageType_descriptor() {
    return ServiceResponse_MessageType_descriptor();
  }
  static inline const ::std::string& MessageType_Name(MessageType value) {
    return ServiceResponse_MessageType_Name(value);
  }
  static inline bool MessageType_Parse(const ::std::string& name,
      MessageType* value) {
    return ServiceResponse_MessageType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .uploadercontrol.ServiceResponse.MessageType messageType = 1;
  inline bool has_messagetype() const;
  inline void clear_messagetype();
  static const int kMessageTypeFieldNumber = 1;
  inline ::uploadercontrol::ServiceResponse_MessageType messagetype() const;
  inline void set_messagetype(::uploadercontrol::ServiceResponse_MessageType value);

  // optional .uploadercontrol.ServiceResponse.Authorization authorization = 2;
  inline bool has_authorization() const;
  inline void clear_authorization();
  static const int kAuthorizationFieldNumber = 2;
  inline const ::uploadercontrol::ServiceResponse_Authorization& authorization() const;
  inline ::uploadercontrol::ServiceResponse_Authorization* mutable_authorization();
  inline ::uploadercontrol::ServiceResponse_Authorization* release_authorization();
  inline void set_allocated_authorization(::uploadercontrol::ServiceResponse_Authorization* authorization);

  // optional .uploadercontrol.ServiceResponse.FileStatus fileStatus = 3;
  inline bool has_filestatus() const;
  inline void clear_filestatus();
  static const int kFileStatusFieldNumber = 3;
  inline const ::uploadercontrol::ServiceResponse_FileStatus& filestatus() const;
  inline ::uploadercontrol::ServiceResponse_FileStatus* mutable_filestatus();
  inline ::uploadercontrol::ServiceResponse_FileStatus* release_filestatus();
  inline void set_allocated_filestatus(::uploadercontrol::ServiceResponse_FileStatus* filestatus);

  // optional .uploadercontrol.ServiceResponse.CopyingStatus copyingStatus = 4;
  inline bool has_copyingstatus() const;
  inline void clear_copyingstatus();
  static const int kCopyingStatusFieldNumber = 4;
  inline const ::uploadercontrol::ServiceResponse_CopyingStatus& copyingstatus() const;
  inline ::uploadercontrol::ServiceResponse_CopyingStatus* mutable_copyingstatus();
  inline ::uploadercontrol::ServiceResponse_CopyingStatus* release_copyingstatus();
  inline void set_allocated_copyingstatus(::uploadercontrol::ServiceResponse_CopyingStatus* copyingstatus);

  // optional .uploadercontrol.ServiceResponse.MaintenanceStatus maintenanceStatus = 5;
  inline bool has_maintenancestatus() const;
  inline void clear_maintenancestatus();
  static const int kMaintenanceStatusFieldNumber = 5;
  inline const ::uploadercontrol::ServiceResponse_MaintenanceStatus& maintenancestatus() const;
  inline ::uploadercontrol::ServiceResponse_MaintenanceStatus* mutable_maintenancestatus();
  inline ::uploadercontrol::ServiceResponse_MaintenanceStatus* release_maintenancestatus();
  inline void set_allocated_maintenancestatus(::uploadercontrol::ServiceResponse_MaintenanceStatus* maintenancestatus);

  // optional .uploadercontrol.ServiceResponse.Error error = 6;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 6;
  inline const ::uploadercontrol::ServiceResponse_Error& error() const;
  inline ::uploadercontrol::ServiceResponse_Error* mutable_error();
  inline ::uploadercontrol::ServiceResponse_Error* release_error();
  inline void set_allocated_error(::uploadercontrol::ServiceResponse_Error* error);

  // optional .uploadercontrol.ServiceResponse.FileList fileList = 7;
  inline bool has_filelist() const;
  inline void clear_filelist();
  static const int kFileListFieldNumber = 7;
  inline const ::uploadercontrol::ServiceResponse_FileList& filelist() const;
  inline ::uploadercontrol::ServiceResponse_FileList* mutable_filelist();
  inline ::uploadercontrol::ServiceResponse_FileList* release_filelist();
  inline void set_allocated_filelist(::uploadercontrol::ServiceResponse_FileList* filelist);

  // @@protoc_insertion_point(class_scope:uploadercontrol.ServiceResponse)
 private:
  inline void set_has_messagetype();
  inline void clear_has_messagetype();
  inline void set_has_authorization();
  inline void clear_has_authorization();
  inline void set_has_filestatus();
  inline void clear_has_filestatus();
  inline void set_has_copyingstatus();
  inline void clear_has_copyingstatus();
  inline void set_has_maintenancestatus();
  inline void clear_has_maintenancestatus();
  inline void set_has_error();
  inline void clear_has_error();
  inline void set_has_filelist();
  inline void clear_has_filelist();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::uploadercontrol::ServiceResponse_Authorization* authorization_;
  ::uploadercontrol::ServiceResponse_FileStatus* filestatus_;
  ::uploadercontrol::ServiceResponse_CopyingStatus* copyingstatus_;
  ::uploadercontrol::ServiceResponse_MaintenanceStatus* maintenancestatus_;
  ::uploadercontrol::ServiceResponse_Error* error_;
  ::uploadercontrol::ServiceResponse_FileList* filelist_;
  int messagetype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_remoteclient_2eproto();
  friend void protobuf_AssignDesc_remoteclient_2eproto();
  friend void protobuf_ShutdownFile_remoteclient_2eproto();

  void InitAsDefaultInstance();
  static ServiceResponse* default_instance_;
};
// ===================================================================


// ===================================================================

// ClientRequest_Authorization

// required string login = 1;
inline bool ClientRequest_Authorization::has_login() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientRequest_Authorization::set_has_login() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientRequest_Authorization::clear_has_login() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientRequest_Authorization::clear_login() {
  if (login_ != &::google::protobuf::internal::kEmptyString) {
    login_->clear();
  }
  clear_has_login();
}
inline const ::std::string& ClientRequest_Authorization::login() const {
  return *login_;
}
inline void ClientRequest_Authorization::set_login(const ::std::string& value) {
  set_has_login();
  if (login_ == &::google::protobuf::internal::kEmptyString) {
    login_ = new ::std::string;
  }
  login_->assign(value);
}
inline void ClientRequest_Authorization::set_login(const char* value) {
  set_has_login();
  if (login_ == &::google::protobuf::internal::kEmptyString) {
    login_ = new ::std::string;
  }
  login_->assign(value);
}
inline void ClientRequest_Authorization::set_login(const char* value, size_t size) {
  set_has_login();
  if (login_ == &::google::protobuf::internal::kEmptyString) {
    login_ = new ::std::string;
  }
  login_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientRequest_Authorization::mutable_login() {
  set_has_login();
  if (login_ == &::google::protobuf::internal::kEmptyString) {
    login_ = new ::std::string;
  }
  return login_;
}
inline ::std::string* ClientRequest_Authorization::release_login() {
  clear_has_login();
  if (login_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = login_;
    login_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientRequest_Authorization::set_allocated_login(::std::string* login) {
  if (login_ != &::google::protobuf::internal::kEmptyString) {
    delete login_;
  }
  if (login) {
    set_has_login();
    login_ = login;
  } else {
    clear_has_login();
    login_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string passwordHash = 2;
inline bool ClientRequest_Authorization::has_passwordhash() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientRequest_Authorization::set_has_passwordhash() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientRequest_Authorization::clear_has_passwordhash() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientRequest_Authorization::clear_passwordhash() {
  if (passwordhash_ != &::google::protobuf::internal::kEmptyString) {
    passwordhash_->clear();
  }
  clear_has_passwordhash();
}
inline const ::std::string& ClientRequest_Authorization::passwordhash() const {
  return *passwordhash_;
}
inline void ClientRequest_Authorization::set_passwordhash(const ::std::string& value) {
  set_has_passwordhash();
  if (passwordhash_ == &::google::protobuf::internal::kEmptyString) {
    passwordhash_ = new ::std::string;
  }
  passwordhash_->assign(value);
}
inline void ClientRequest_Authorization::set_passwordhash(const char* value) {
  set_has_passwordhash();
  if (passwordhash_ == &::google::protobuf::internal::kEmptyString) {
    passwordhash_ = new ::std::string;
  }
  passwordhash_->assign(value);
}
inline void ClientRequest_Authorization::set_passwordhash(const char* value, size_t size) {
  set_has_passwordhash();
  if (passwordhash_ == &::google::protobuf::internal::kEmptyString) {
    passwordhash_ = new ::std::string;
  }
  passwordhash_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientRequest_Authorization::mutable_passwordhash() {
  set_has_passwordhash();
  if (passwordhash_ == &::google::protobuf::internal::kEmptyString) {
    passwordhash_ = new ::std::string;
  }
  return passwordhash_;
}
inline ::std::string* ClientRequest_Authorization::release_passwordhash() {
  clear_has_passwordhash();
  if (passwordhash_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = passwordhash_;
    passwordhash_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientRequest_Authorization::set_allocated_passwordhash(::std::string* passwordhash) {
  if (passwordhash_ != &::google::protobuf::internal::kEmptyString) {
    delete passwordhash_;
  }
  if (passwordhash) {
    set_has_passwordhash();
    passwordhash_ = passwordhash;
  } else {
    clear_has_passwordhash();
    passwordhash_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string host = 3;
inline bool ClientRequest_Authorization::has_host() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClientRequest_Authorization::set_has_host() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClientRequest_Authorization::clear_has_host() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClientRequest_Authorization::clear_host() {
  if (host_ != &::google::protobuf::internal::kEmptyString) {
    host_->clear();
  }
  clear_has_host();
}
inline const ::std::string& ClientRequest_Authorization::host() const {
  return *host_;
}
inline void ClientRequest_Authorization::set_host(const ::std::string& value) {
  set_has_host();
  if (host_ == &::google::protobuf::internal::kEmptyString) {
    host_ = new ::std::string;
  }
  host_->assign(value);
}
inline void ClientRequest_Authorization::set_host(const char* value) {
  set_has_host();
  if (host_ == &::google::protobuf::internal::kEmptyString) {
    host_ = new ::std::string;
  }
  host_->assign(value);
}
inline void ClientRequest_Authorization::set_host(const char* value, size_t size) {
  set_has_host();
  if (host_ == &::google::protobuf::internal::kEmptyString) {
    host_ = new ::std::string;
  }
  host_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientRequest_Authorization::mutable_host() {
  set_has_host();
  if (host_ == &::google::protobuf::internal::kEmptyString) {
    host_ = new ::std::string;
  }
  return host_;
}
inline ::std::string* ClientRequest_Authorization::release_host() {
  clear_has_host();
  if (host_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = host_;
    host_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientRequest_Authorization::set_allocated_host(::std::string* host) {
  if (host_ != &::google::protobuf::internal::kEmptyString) {
    delete host_;
  }
  if (host) {
    set_has_host();
    host_ = host;
  } else {
    clear_has_host();
    host_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 port = 4;
inline bool ClientRequest_Authorization::has_port() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ClientRequest_Authorization::set_has_port() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ClientRequest_Authorization::clear_has_port() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ClientRequest_Authorization::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 ClientRequest_Authorization::port() const {
  return port_;
}
inline void ClientRequest_Authorization::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
}

// optional bool terminateUser = 5;
inline bool ClientRequest_Authorization::has_terminateuser() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ClientRequest_Authorization::set_has_terminateuser() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ClientRequest_Authorization::clear_has_terminateuser() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ClientRequest_Authorization::clear_terminateuser() {
  terminateuser_ = false;
  clear_has_terminateuser();
}
inline bool ClientRequest_Authorization::terminateuser() const {
  return terminateuser_;
}
inline void ClientRequest_Authorization::set_terminateuser(bool value) {
  set_has_terminateuser();
  terminateuser_ = value;
}

// -------------------------------------------------------------------

// ClientRequest_AddTask_File

// required string pathName = 2;
inline bool ClientRequest_AddTask_File::has_pathname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientRequest_AddTask_File::set_has_pathname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientRequest_AddTask_File::clear_has_pathname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientRequest_AddTask_File::clear_pathname() {
  if (pathname_ != &::google::protobuf::internal::kEmptyString) {
    pathname_->clear();
  }
  clear_has_pathname();
}
inline const ::std::string& ClientRequest_AddTask_File::pathname() const {
  return *pathname_;
}
inline void ClientRequest_AddTask_File::set_pathname(const ::std::string& value) {
  set_has_pathname();
  if (pathname_ == &::google::protobuf::internal::kEmptyString) {
    pathname_ = new ::std::string;
  }
  pathname_->assign(value);
}
inline void ClientRequest_AddTask_File::set_pathname(const char* value) {
  set_has_pathname();
  if (pathname_ == &::google::protobuf::internal::kEmptyString) {
    pathname_ = new ::std::string;
  }
  pathname_->assign(value);
}
inline void ClientRequest_AddTask_File::set_pathname(const char* value, size_t size) {
  set_has_pathname();
  if (pathname_ == &::google::protobuf::internal::kEmptyString) {
    pathname_ = new ::std::string;
  }
  pathname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientRequest_AddTask_File::mutable_pathname() {
  set_has_pathname();
  if (pathname_ == &::google::protobuf::internal::kEmptyString) {
    pathname_ = new ::std::string;
  }
  return pathname_;
}
inline ::std::string* ClientRequest_AddTask_File::release_pathname() {
  clear_has_pathname();
  if (pathname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pathname_;
    pathname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientRequest_AddTask_File::set_allocated_pathname(::std::string* pathname) {
  if (pathname_ != &::google::protobuf::internal::kEmptyString) {
    delete pathname_;
  }
  if (pathname) {
    set_has_pathname();
    pathname_ = pathname;
  } else {
    clear_has_pathname();
    pathname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .uploadercontrol.FileType filetype = 3;
inline bool ClientRequest_AddTask_File::has_filetype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientRequest_AddTask_File::set_has_filetype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientRequest_AddTask_File::clear_has_filetype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientRequest_AddTask_File::clear_filetype() {
  filetype_ = 1;
  clear_has_filetype();
}
inline ::uploadercontrol::FileType ClientRequest_AddTask_File::filetype() const {
  return static_cast< ::uploadercontrol::FileType >(filetype_);
}
inline void ClientRequest_AddTask_File::set_filetype(::uploadercontrol::FileType value) {
  assert(::uploadercontrol::FileType_IsValid(value));
  set_has_filetype();
  filetype_ = value;
}

// required bool isBackup = 4;
inline bool ClientRequest_AddTask_File::has_isbackup() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClientRequest_AddTask_File::set_has_isbackup() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClientRequest_AddTask_File::clear_has_isbackup() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClientRequest_AddTask_File::clear_isbackup() {
  isbackup_ = false;
  clear_has_isbackup();
}
inline bool ClientRequest_AddTask_File::isbackup() const {
  return isbackup_;
}
inline void ClientRequest_AddTask_File::set_isbackup(bool value) {
  set_has_isbackup();
  isbackup_ = value;
}

// -------------------------------------------------------------------

// ClientRequest_AddTask

// required string taskName = 1;
inline bool ClientRequest_AddTask::has_taskname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientRequest_AddTask::set_has_taskname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientRequest_AddTask::clear_has_taskname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientRequest_AddTask::clear_taskname() {
  if (taskname_ != &::google::protobuf::internal::kEmptyString) {
    taskname_->clear();
  }
  clear_has_taskname();
}
inline const ::std::string& ClientRequest_AddTask::taskname() const {
  return *taskname_;
}
inline void ClientRequest_AddTask::set_taskname(const ::std::string& value) {
  set_has_taskname();
  if (taskname_ == &::google::protobuf::internal::kEmptyString) {
    taskname_ = new ::std::string;
  }
  taskname_->assign(value);
}
inline void ClientRequest_AddTask::set_taskname(const char* value) {
  set_has_taskname();
  if (taskname_ == &::google::protobuf::internal::kEmptyString) {
    taskname_ = new ::std::string;
  }
  taskname_->assign(value);
}
inline void ClientRequest_AddTask::set_taskname(const char* value, size_t size) {
  set_has_taskname();
  if (taskname_ == &::google::protobuf::internal::kEmptyString) {
    taskname_ = new ::std::string;
  }
  taskname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientRequest_AddTask::mutable_taskname() {
  set_has_taskname();
  if (taskname_ == &::google::protobuf::internal::kEmptyString) {
    taskname_ = new ::std::string;
  }
  return taskname_;
}
inline ::std::string* ClientRequest_AddTask::release_taskname() {
  clear_has_taskname();
  if (taskname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = taskname_;
    taskname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientRequest_AddTask::set_allocated_taskname(::std::string* taskname) {
  if (taskname_ != &::google::protobuf::internal::kEmptyString) {
    delete taskname_;
  }
  if (taskname) {
    set_has_taskname();
    taskname_ = taskname;
  } else {
    clear_has_taskname();
    taskname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .uploadercontrol.ClientRequest.AddTask.File files = 2;
inline int ClientRequest_AddTask::files_size() const {
  return files_.size();
}
inline void ClientRequest_AddTask::clear_files() {
  files_.Clear();
}
inline const ::uploadercontrol::ClientRequest_AddTask_File& ClientRequest_AddTask::files(int index) const {
  return files_.Get(index);
}
inline ::uploadercontrol::ClientRequest_AddTask_File* ClientRequest_AddTask::mutable_files(int index) {
  return files_.Mutable(index);
}
inline ::uploadercontrol::ClientRequest_AddTask_File* ClientRequest_AddTask::add_files() {
  return files_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::uploadercontrol::ClientRequest_AddTask_File >&
ClientRequest_AddTask::files() const {
  return files_;
}
inline ::google::protobuf::RepeatedPtrField< ::uploadercontrol::ClientRequest_AddTask_File >*
ClientRequest_AddTask::mutable_files() {
  return &files_;
}

// required bool doCopy = 3;
inline bool ClientRequest_AddTask::has_docopy() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClientRequest_AddTask::set_has_docopy() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClientRequest_AddTask::clear_has_docopy() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClientRequest_AddTask::clear_docopy() {
  docopy_ = false;
  clear_has_docopy();
}
inline bool ClientRequest_AddTask::docopy() const {
  return docopy_;
}
inline void ClientRequest_AddTask::set_docopy(bool value) {
  set_has_docopy();
  docopy_ = value;
}

// required bool removeSourceFiles = 4;
inline bool ClientRequest_AddTask::has_removesourcefiles() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ClientRequest_AddTask::set_has_removesourcefiles() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ClientRequest_AddTask::clear_has_removesourcefiles() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ClientRequest_AddTask::clear_removesourcefiles() {
  removesourcefiles_ = false;
  clear_has_removesourcefiles();
}
inline bool ClientRequest_AddTask::removesourcefiles() const {
  return removesourcefiles_;
}
inline void ClientRequest_AddTask::set_removesourcefiles(bool value) {
  set_has_removesourcefiles();
  removesourcefiles_ = value;
}

// required bool index = 5;
inline bool ClientRequest_AddTask::has_index() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ClientRequest_AddTask::set_has_index() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ClientRequest_AddTask::clear_has_index() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ClientRequest_AddTask::clear_index() {
  index_ = false;
  clear_has_index();
}
inline bool ClientRequest_AddTask::index() const {
  return index_;
}
inline void ClientRequest_AddTask::set_index(bool value) {
  set_has_index();
  index_ = value;
}

// -------------------------------------------------------------------

// ClientRequest_Command

// optional string checkSum = 1;
inline bool ClientRequest_Command::has_checksum() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientRequest_Command::set_has_checksum() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientRequest_Command::clear_has_checksum() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientRequest_Command::clear_checksum() {
  if (checksum_ != &::google::protobuf::internal::kEmptyString) {
    checksum_->clear();
  }
  clear_has_checksum();
}
inline const ::std::string& ClientRequest_Command::checksum() const {
  return *checksum_;
}
inline void ClientRequest_Command::set_checksum(const ::std::string& value) {
  set_has_checksum();
  if (checksum_ == &::google::protobuf::internal::kEmptyString) {
    checksum_ = new ::std::string;
  }
  checksum_->assign(value);
}
inline void ClientRequest_Command::set_checksum(const char* value) {
  set_has_checksum();
  if (checksum_ == &::google::protobuf::internal::kEmptyString) {
    checksum_ = new ::std::string;
  }
  checksum_->assign(value);
}
inline void ClientRequest_Command::set_checksum(const char* value, size_t size) {
  set_has_checksum();
  if (checksum_ == &::google::protobuf::internal::kEmptyString) {
    checksum_ = new ::std::string;
  }
  checksum_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientRequest_Command::mutable_checksum() {
  set_has_checksum();
  if (checksum_ == &::google::protobuf::internal::kEmptyString) {
    checksum_ = new ::std::string;
  }
  return checksum_;
}
inline ::std::string* ClientRequest_Command::release_checksum() {
  clear_has_checksum();
  if (checksum_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = checksum_;
    checksum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientRequest_Command::set_allocated_checksum(::std::string* checksum) {
  if (checksum_ != &::google::protobuf::internal::kEmptyString) {
    delete checksum_;
  }
  if (checksum) {
    set_has_checksum();
    checksum_ = checksum;
  } else {
    clear_has_checksum();
    checksum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool isBackup = 2;
inline bool ClientRequest_Command::has_isbackup() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientRequest_Command::set_has_isbackup() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientRequest_Command::clear_has_isbackup() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientRequest_Command::clear_isbackup() {
  isbackup_ = false;
  clear_has_isbackup();
}
inline bool ClientRequest_Command::isbackup() const {
  return isbackup_;
}
inline void ClientRequest_Command::set_isbackup(bool value) {
  set_has_isbackup();
  isbackup_ = value;
}

// required .uploadercontrol.CommandType commandType = 3;
inline bool ClientRequest_Command::has_commandtype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClientRequest_Command::set_has_commandtype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClientRequest_Command::clear_has_commandtype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClientRequest_Command::clear_commandtype() {
  commandtype_ = 1;
  clear_has_commandtype();
}
inline ::uploadercontrol::CommandType ClientRequest_Command::commandtype() const {
  return static_cast< ::uploadercontrol::CommandType >(commandtype_);
}
inline void ClientRequest_Command::set_commandtype(::uploadercontrol::CommandType value) {
  assert(::uploadercontrol::CommandType_IsValid(value));
  set_has_commandtype();
  commandtype_ = value;
}

// -------------------------------------------------------------------

// ClientRequest_Maintaince

// required .uploadercontrol.RequestType requestType = 1;
inline bool ClientRequest_Maintaince::has_requesttype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientRequest_Maintaince::set_has_requesttype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientRequest_Maintaince::clear_has_requesttype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientRequest_Maintaince::clear_requesttype() {
  requesttype_ = 1;
  clear_has_requesttype();
}
inline ::uploadercontrol::RequestType ClientRequest_Maintaince::requesttype() const {
  return static_cast< ::uploadercontrol::RequestType >(requesttype_);
}
inline void ClientRequest_Maintaince::set_requesttype(::uploadercontrol::RequestType value) {
  assert(::uploadercontrol::RequestType_IsValid(value));
  set_has_requesttype();
  requesttype_ = value;
}

// optional string login = 2;
inline bool ClientRequest_Maintaince::has_login() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientRequest_Maintaince::set_has_login() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientRequest_Maintaince::clear_has_login() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientRequest_Maintaince::clear_login() {
  if (login_ != &::google::protobuf::internal::kEmptyString) {
    login_->clear();
  }
  clear_has_login();
}
inline const ::std::string& ClientRequest_Maintaince::login() const {
  return *login_;
}
inline void ClientRequest_Maintaince::set_login(const ::std::string& value) {
  set_has_login();
  if (login_ == &::google::protobuf::internal::kEmptyString) {
    login_ = new ::std::string;
  }
  login_->assign(value);
}
inline void ClientRequest_Maintaince::set_login(const char* value) {
  set_has_login();
  if (login_ == &::google::protobuf::internal::kEmptyString) {
    login_ = new ::std::string;
  }
  login_->assign(value);
}
inline void ClientRequest_Maintaince::set_login(const char* value, size_t size) {
  set_has_login();
  if (login_ == &::google::protobuf::internal::kEmptyString) {
    login_ = new ::std::string;
  }
  login_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientRequest_Maintaince::mutable_login() {
  set_has_login();
  if (login_ == &::google::protobuf::internal::kEmptyString) {
    login_ = new ::std::string;
  }
  return login_;
}
inline ::std::string* ClientRequest_Maintaince::release_login() {
  clear_has_login();
  if (login_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = login_;
    login_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientRequest_Maintaince::set_allocated_login(::std::string* login) {
  if (login_ != &::google::protobuf::internal::kEmptyString) {
    delete login_;
  }
  if (login) {
    set_has_login();
    login_ = login;
  } else {
    clear_has_login();
    login_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool removeSourceFiles = 3;
inline bool ClientRequest_Maintaince::has_removesourcefiles() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClientRequest_Maintaince::set_has_removesourcefiles() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClientRequest_Maintaince::clear_has_removesourcefiles() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClientRequest_Maintaince::clear_removesourcefiles() {
  removesourcefiles_ = false;
  clear_has_removesourcefiles();
}
inline bool ClientRequest_Maintaince::removesourcefiles() const {
  return removesourcefiles_;
}
inline void ClientRequest_Maintaince::set_removesourcefiles(bool value) {
  set_has_removesourcefiles();
  removesourcefiles_ = value;
}

// -------------------------------------------------------------------

// ClientRequest_OpenItem

// required string item = 1;
inline bool ClientRequest_OpenItem::has_item() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientRequest_OpenItem::set_has_item() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientRequest_OpenItem::clear_has_item() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientRequest_OpenItem::clear_item() {
  if (item_ != &::google::protobuf::internal::kEmptyString) {
    item_->clear();
  }
  clear_has_item();
}
inline const ::std::string& ClientRequest_OpenItem::item() const {
  return *item_;
}
inline void ClientRequest_OpenItem::set_item(const ::std::string& value) {
  set_has_item();
  if (item_ == &::google::protobuf::internal::kEmptyString) {
    item_ = new ::std::string;
  }
  item_->assign(value);
}
inline void ClientRequest_OpenItem::set_item(const char* value) {
  set_has_item();
  if (item_ == &::google::protobuf::internal::kEmptyString) {
    item_ = new ::std::string;
  }
  item_->assign(value);
}
inline void ClientRequest_OpenItem::set_item(const char* value, size_t size) {
  set_has_item();
  if (item_ == &::google::protobuf::internal::kEmptyString) {
    item_ = new ::std::string;
  }
  item_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientRequest_OpenItem::mutable_item() {
  set_has_item();
  if (item_ == &::google::protobuf::internal::kEmptyString) {
    item_ = new ::std::string;
  }
  return item_;
}
inline ::std::string* ClientRequest_OpenItem::release_item() {
  clear_has_item();
  if (item_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = item_;
    item_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientRequest_OpenItem::set_allocated_item(::std::string* item) {
  if (item_ != &::google::protobuf::internal::kEmptyString) {
    delete item_;
  }
  if (item) {
    set_has_item();
    item_ = item;
  } else {
    clear_has_item();
    item_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required bool listRecursively = 2;
inline bool ClientRequest_OpenItem::has_listrecursively() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientRequest_OpenItem::set_has_listrecursively() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientRequest_OpenItem::clear_has_listrecursively() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientRequest_OpenItem::clear_listrecursively() {
  listrecursively_ = false;
  clear_has_listrecursively();
}
inline bool ClientRequest_OpenItem::listrecursively() const {
  return listrecursively_;
}
inline void ClientRequest_OpenItem::set_listrecursively(bool value) {
  set_has_listrecursively();
  listrecursively_ = value;
}

// -------------------------------------------------------------------

// ClientRequest

// required .uploadercontrol.ClientRequest.MessageType messageType = 1;
inline bool ClientRequest::has_messagetype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientRequest::set_has_messagetype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientRequest::clear_has_messagetype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientRequest::clear_messagetype() {
  messagetype_ = 1;
  clear_has_messagetype();
}
inline ::uploadercontrol::ClientRequest_MessageType ClientRequest::messagetype() const {
  return static_cast< ::uploadercontrol::ClientRequest_MessageType >(messagetype_);
}
inline void ClientRequest::set_messagetype(::uploadercontrol::ClientRequest_MessageType value) {
  assert(::uploadercontrol::ClientRequest_MessageType_IsValid(value));
  set_has_messagetype();
  messagetype_ = value;
}

// optional .uploadercontrol.ClientRequest.Authorization authorization = 2;
inline bool ClientRequest::has_authorization() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientRequest::set_has_authorization() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientRequest::clear_has_authorization() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientRequest::clear_authorization() {
  if (authorization_ != NULL) authorization_->::uploadercontrol::ClientRequest_Authorization::Clear();
  clear_has_authorization();
}
inline const ::uploadercontrol::ClientRequest_Authorization& ClientRequest::authorization() const {
  return authorization_ != NULL ? *authorization_ : *default_instance_->authorization_;
}
inline ::uploadercontrol::ClientRequest_Authorization* ClientRequest::mutable_authorization() {
  set_has_authorization();
  if (authorization_ == NULL) authorization_ = new ::uploadercontrol::ClientRequest_Authorization;
  return authorization_;
}
inline ::uploadercontrol::ClientRequest_Authorization* ClientRequest::release_authorization() {
  clear_has_authorization();
  ::uploadercontrol::ClientRequest_Authorization* temp = authorization_;
  authorization_ = NULL;
  return temp;
}
inline void ClientRequest::set_allocated_authorization(::uploadercontrol::ClientRequest_Authorization* authorization) {
  delete authorization_;
  authorization_ = authorization;
  if (authorization) {
    set_has_authorization();
  } else {
    clear_has_authorization();
  }
}

// optional .uploadercontrol.ClientRequest.AddTask addTask = 3;
inline bool ClientRequest::has_addtask() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClientRequest::set_has_addtask() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClientRequest::clear_has_addtask() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClientRequest::clear_addtask() {
  if (addtask_ != NULL) addtask_->::uploadercontrol::ClientRequest_AddTask::Clear();
  clear_has_addtask();
}
inline const ::uploadercontrol::ClientRequest_AddTask& ClientRequest::addtask() const {
  return addtask_ != NULL ? *addtask_ : *default_instance_->addtask_;
}
inline ::uploadercontrol::ClientRequest_AddTask* ClientRequest::mutable_addtask() {
  set_has_addtask();
  if (addtask_ == NULL) addtask_ = new ::uploadercontrol::ClientRequest_AddTask;
  return addtask_;
}
inline ::uploadercontrol::ClientRequest_AddTask* ClientRequest::release_addtask() {
  clear_has_addtask();
  ::uploadercontrol::ClientRequest_AddTask* temp = addtask_;
  addtask_ = NULL;
  return temp;
}
inline void ClientRequest::set_allocated_addtask(::uploadercontrol::ClientRequest_AddTask* addtask) {
  delete addtask_;
  addtask_ = addtask;
  if (addtask) {
    set_has_addtask();
  } else {
    clear_has_addtask();
  }
}

// optional .uploadercontrol.ClientRequest.Command command = 4;
inline bool ClientRequest::has_command() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ClientRequest::set_has_command() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ClientRequest::clear_has_command() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ClientRequest::clear_command() {
  if (command_ != NULL) command_->::uploadercontrol::ClientRequest_Command::Clear();
  clear_has_command();
}
inline const ::uploadercontrol::ClientRequest_Command& ClientRequest::command() const {
  return command_ != NULL ? *command_ : *default_instance_->command_;
}
inline ::uploadercontrol::ClientRequest_Command* ClientRequest::mutable_command() {
  set_has_command();
  if (command_ == NULL) command_ = new ::uploadercontrol::ClientRequest_Command;
  return command_;
}
inline ::uploadercontrol::ClientRequest_Command* ClientRequest::release_command() {
  clear_has_command();
  ::uploadercontrol::ClientRequest_Command* temp = command_;
  command_ = NULL;
  return temp;
}
inline void ClientRequest::set_allocated_command(::uploadercontrol::ClientRequest_Command* command) {
  delete command_;
  command_ = command;
  if (command) {
    set_has_command();
  } else {
    clear_has_command();
  }
}

// optional .uploadercontrol.ClientRequest.Maintaince maintaince = 5;
inline bool ClientRequest::has_maintaince() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ClientRequest::set_has_maintaince() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ClientRequest::clear_has_maintaince() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ClientRequest::clear_maintaince() {
  if (maintaince_ != NULL) maintaince_->::uploadercontrol::ClientRequest_Maintaince::Clear();
  clear_has_maintaince();
}
inline const ::uploadercontrol::ClientRequest_Maintaince& ClientRequest::maintaince() const {
  return maintaince_ != NULL ? *maintaince_ : *default_instance_->maintaince_;
}
inline ::uploadercontrol::ClientRequest_Maintaince* ClientRequest::mutable_maintaince() {
  set_has_maintaince();
  if (maintaince_ == NULL) maintaince_ = new ::uploadercontrol::ClientRequest_Maintaince;
  return maintaince_;
}
inline ::uploadercontrol::ClientRequest_Maintaince* ClientRequest::release_maintaince() {
  clear_has_maintaince();
  ::uploadercontrol::ClientRequest_Maintaince* temp = maintaince_;
  maintaince_ = NULL;
  return temp;
}
inline void ClientRequest::set_allocated_maintaince(::uploadercontrol::ClientRequest_Maintaince* maintaince) {
  delete maintaince_;
  maintaince_ = maintaince;
  if (maintaince) {
    set_has_maintaince();
  } else {
    clear_has_maintaince();
  }
}

// optional .uploadercontrol.ClientRequest.OpenItem openItem = 6;
inline bool ClientRequest::has_openitem() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ClientRequest::set_has_openitem() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ClientRequest::clear_has_openitem() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ClientRequest::clear_openitem() {
  if (openitem_ != NULL) openitem_->::uploadercontrol::ClientRequest_OpenItem::Clear();
  clear_has_openitem();
}
inline const ::uploadercontrol::ClientRequest_OpenItem& ClientRequest::openitem() const {
  return openitem_ != NULL ? *openitem_ : *default_instance_->openitem_;
}
inline ::uploadercontrol::ClientRequest_OpenItem* ClientRequest::mutable_openitem() {
  set_has_openitem();
  if (openitem_ == NULL) openitem_ = new ::uploadercontrol::ClientRequest_OpenItem;
  return openitem_;
}
inline ::uploadercontrol::ClientRequest_OpenItem* ClientRequest::release_openitem() {
  clear_has_openitem();
  ::uploadercontrol::ClientRequest_OpenItem* temp = openitem_;
  openitem_ = NULL;
  return temp;
}
inline void ClientRequest::set_allocated_openitem(::uploadercontrol::ClientRequest_OpenItem* openitem) {
  delete openitem_;
  openitem_ = openitem;
  if (openitem) {
    set_has_openitem();
  } else {
    clear_has_openitem();
  }
}

// -------------------------------------------------------------------

// ServiceResponse_Authorization

// required bool isOk = 1 [default = false];
inline bool ServiceResponse_Authorization::has_isok() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServiceResponse_Authorization::set_has_isok() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServiceResponse_Authorization::clear_has_isok() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServiceResponse_Authorization::clear_isok() {
  isok_ = false;
  clear_has_isok();
}
inline bool ServiceResponse_Authorization::isok() const {
  return isok_;
}
inline void ServiceResponse_Authorization::set_isok(bool value) {
  set_has_isok();
  isok_ = value;
}

// required bool isAdmin = 2;
inline bool ServiceResponse_Authorization::has_isadmin() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ServiceResponse_Authorization::set_has_isadmin() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ServiceResponse_Authorization::clear_has_isadmin() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ServiceResponse_Authorization::clear_isadmin() {
  isadmin_ = false;
  clear_has_isadmin();
}
inline bool ServiceResponse_Authorization::isadmin() const {
  return isadmin_;
}
inline void ServiceResponse_Authorization::set_isadmin(bool value) {
  set_has_isadmin();
  isadmin_ = value;
}

// required bool alreadyAuthorized = 3;
inline bool ServiceResponse_Authorization::has_alreadyauthorized() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ServiceResponse_Authorization::set_has_alreadyauthorized() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ServiceResponse_Authorization::clear_has_alreadyauthorized() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ServiceResponse_Authorization::clear_alreadyauthorized() {
  alreadyauthorized_ = false;
  clear_has_alreadyauthorized();
}
inline bool ServiceResponse_Authorization::alreadyauthorized() const {
  return alreadyauthorized_;
}
inline void ServiceResponse_Authorization::set_alreadyauthorized(bool value) {
  set_has_alreadyauthorized();
  alreadyauthorized_ = value;
}

// -------------------------------------------------------------------

// ServiceResponse_FileStatus_FileInfo

// required string task = 1;
inline bool ServiceResponse_FileStatus_FileInfo::has_task() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServiceResponse_FileStatus_FileInfo::set_has_task() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServiceResponse_FileStatus_FileInfo::clear_has_task() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServiceResponse_FileStatus_FileInfo::clear_task() {
  if (task_ != &::google::protobuf::internal::kEmptyString) {
    task_->clear();
  }
  clear_has_task();
}
inline const ::std::string& ServiceResponse_FileStatus_FileInfo::task() const {
  return *task_;
}
inline void ServiceResponse_FileStatus_FileInfo::set_task(const ::std::string& value) {
  set_has_task();
  if (task_ == &::google::protobuf::internal::kEmptyString) {
    task_ = new ::std::string;
  }
  task_->assign(value);
}
inline void ServiceResponse_FileStatus_FileInfo::set_task(const char* value) {
  set_has_task();
  if (task_ == &::google::protobuf::internal::kEmptyString) {
    task_ = new ::std::string;
  }
  task_->assign(value);
}
inline void ServiceResponse_FileStatus_FileInfo::set_task(const char* value, size_t size) {
  set_has_task();
  if (task_ == &::google::protobuf::internal::kEmptyString) {
    task_ = new ::std::string;
  }
  task_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServiceResponse_FileStatus_FileInfo::mutable_task() {
  set_has_task();
  if (task_ == &::google::protobuf::internal::kEmptyString) {
    task_ = new ::std::string;
  }
  return task_;
}
inline ::std::string* ServiceResponse_FileStatus_FileInfo::release_task() {
  clear_has_task();
  if (task_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = task_;
    task_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ServiceResponse_FileStatus_FileInfo::set_allocated_task(::std::string* task) {
  if (task_ != &::google::protobuf::internal::kEmptyString) {
    delete task_;
  }
  if (task) {
    set_has_task();
    task_ = task;
  } else {
    clear_has_task();
    task_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string pathName = 2;
inline bool ServiceResponse_FileStatus_FileInfo::has_pathname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ServiceResponse_FileStatus_FileInfo::set_has_pathname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ServiceResponse_FileStatus_FileInfo::clear_has_pathname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ServiceResponse_FileStatus_FileInfo::clear_pathname() {
  if (pathname_ != &::google::protobuf::internal::kEmptyString) {
    pathname_->clear();
  }
  clear_has_pathname();
}
inline const ::std::string& ServiceResponse_FileStatus_FileInfo::pathname() const {
  return *pathname_;
}
inline void ServiceResponse_FileStatus_FileInfo::set_pathname(const ::std::string& value) {
  set_has_pathname();
  if (pathname_ == &::google::protobuf::internal::kEmptyString) {
    pathname_ = new ::std::string;
  }
  pathname_->assign(value);
}
inline void ServiceResponse_FileStatus_FileInfo::set_pathname(const char* value) {
  set_has_pathname();
  if (pathname_ == &::google::protobuf::internal::kEmptyString) {
    pathname_ = new ::std::string;
  }
  pathname_->assign(value);
}
inline void ServiceResponse_FileStatus_FileInfo::set_pathname(const char* value, size_t size) {
  set_has_pathname();
  if (pathname_ == &::google::protobuf::internal::kEmptyString) {
    pathname_ = new ::std::string;
  }
  pathname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServiceResponse_FileStatus_FileInfo::mutable_pathname() {
  set_has_pathname();
  if (pathname_ == &::google::protobuf::internal::kEmptyString) {
    pathname_ = new ::std::string;
  }
  return pathname_;
}
inline ::std::string* ServiceResponse_FileStatus_FileInfo::release_pathname() {
  clear_has_pathname();
  if (pathname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pathname_;
    pathname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ServiceResponse_FileStatus_FileInfo::set_allocated_pathname(::std::string* pathname) {
  if (pathname_ != &::google::protobuf::internal::kEmptyString) {
    delete pathname_;
  }
  if (pathname) {
    set_has_pathname();
    pathname_ = pathname;
  } else {
    clear_has_pathname();
    pathname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .uploadercontrol.TaskStatus status = 3;
inline bool ServiceResponse_FileStatus_FileInfo::has_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ServiceResponse_FileStatus_FileInfo::set_has_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ServiceResponse_FileStatus_FileInfo::clear_has_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ServiceResponse_FileStatus_FileInfo::clear_status() {
  status_ = 1;
  clear_has_status();
}
inline ::uploadercontrol::TaskStatus ServiceResponse_FileStatus_FileInfo::status() const {
  return static_cast< ::uploadercontrol::TaskStatus >(status_);
}
inline void ServiceResponse_FileStatus_FileInfo::set_status(::uploadercontrol::TaskStatus value) {
  assert(::uploadercontrol::TaskStatus_IsValid(value));
  set_has_status();
  status_ = value;
}

// optional string fileId = 4;
inline bool ServiceResponse_FileStatus_FileInfo::has_fileid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ServiceResponse_FileStatus_FileInfo::set_has_fileid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ServiceResponse_FileStatus_FileInfo::clear_has_fileid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ServiceResponse_FileStatus_FileInfo::clear_fileid() {
  if (fileid_ != &::google::protobuf::internal::kEmptyString) {
    fileid_->clear();
  }
  clear_has_fileid();
}
inline const ::std::string& ServiceResponse_FileStatus_FileInfo::fileid() const {
  return *fileid_;
}
inline void ServiceResponse_FileStatus_FileInfo::set_fileid(const ::std::string& value) {
  set_has_fileid();
  if (fileid_ == &::google::protobuf::internal::kEmptyString) {
    fileid_ = new ::std::string;
  }
  fileid_->assign(value);
}
inline void ServiceResponse_FileStatus_FileInfo::set_fileid(const char* value) {
  set_has_fileid();
  if (fileid_ == &::google::protobuf::internal::kEmptyString) {
    fileid_ = new ::std::string;
  }
  fileid_->assign(value);
}
inline void ServiceResponse_FileStatus_FileInfo::set_fileid(const char* value, size_t size) {
  set_has_fileid();
  if (fileid_ == &::google::protobuf::internal::kEmptyString) {
    fileid_ = new ::std::string;
  }
  fileid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServiceResponse_FileStatus_FileInfo::mutable_fileid() {
  set_has_fileid();
  if (fileid_ == &::google::protobuf::internal::kEmptyString) {
    fileid_ = new ::std::string;
  }
  return fileid_;
}
inline ::std::string* ServiceResponse_FileStatus_FileInfo::release_fileid() {
  clear_has_fileid();
  if (fileid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = fileid_;
    fileid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ServiceResponse_FileStatus_FileInfo::set_allocated_fileid(::std::string* fileid) {
  if (fileid_ != &::google::protobuf::internal::kEmptyString) {
    delete fileid_;
  }
  if (fileid) {
    set_has_fileid();
    fileid_ = fileid;
  } else {
    clear_has_fileid();
    fileid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint64 size = 5;
inline bool ServiceResponse_FileStatus_FileInfo::has_size() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ServiceResponse_FileStatus_FileInfo::set_has_size() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ServiceResponse_FileStatus_FileInfo::clear_has_size() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ServiceResponse_FileStatus_FileInfo::clear_size() {
  size_ = GOOGLE_ULONGLONG(0);
  clear_has_size();
}
inline ::google::protobuf::uint64 ServiceResponse_FileStatus_FileInfo::size() const {
  return size_;
}
inline void ServiceResponse_FileStatus_FileInfo::set_size(::google::protobuf::uint64 value) {
  set_has_size();
  size_ = value;
}

// required bool isBackup = 6;
inline bool ServiceResponse_FileStatus_FileInfo::has_isbackup() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ServiceResponse_FileStatus_FileInfo::set_has_isbackup() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ServiceResponse_FileStatus_FileInfo::clear_has_isbackup() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ServiceResponse_FileStatus_FileInfo::clear_isbackup() {
  isbackup_ = false;
  clear_has_isbackup();
}
inline bool ServiceResponse_FileStatus_FileInfo::isbackup() const {
  return isbackup_;
}
inline void ServiceResponse_FileStatus_FileInfo::set_isbackup(bool value) {
  set_has_isbackup();
  isbackup_ = value;
}

// required bytes checkSum = 7;
inline bool ServiceResponse_FileStatus_FileInfo::has_checksum() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ServiceResponse_FileStatus_FileInfo::set_has_checksum() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ServiceResponse_FileStatus_FileInfo::clear_has_checksum() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ServiceResponse_FileStatus_FileInfo::clear_checksum() {
  if (checksum_ != &::google::protobuf::internal::kEmptyString) {
    checksum_->clear();
  }
  clear_has_checksum();
}
inline const ::std::string& ServiceResponse_FileStatus_FileInfo::checksum() const {
  return *checksum_;
}
inline void ServiceResponse_FileStatus_FileInfo::set_checksum(const ::std::string& value) {
  set_has_checksum();
  if (checksum_ == &::google::protobuf::internal::kEmptyString) {
    checksum_ = new ::std::string;
  }
  checksum_->assign(value);
}
inline void ServiceResponse_FileStatus_FileInfo::set_checksum(const char* value) {
  set_has_checksum();
  if (checksum_ == &::google::protobuf::internal::kEmptyString) {
    checksum_ = new ::std::string;
  }
  checksum_->assign(value);
}
inline void ServiceResponse_FileStatus_FileInfo::set_checksum(const void* value, size_t size) {
  set_has_checksum();
  if (checksum_ == &::google::protobuf::internal::kEmptyString) {
    checksum_ = new ::std::string;
  }
  checksum_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServiceResponse_FileStatus_FileInfo::mutable_checksum() {
  set_has_checksum();
  if (checksum_ == &::google::protobuf::internal::kEmptyString) {
    checksum_ = new ::std::string;
  }
  return checksum_;
}
inline ::std::string* ServiceResponse_FileStatus_FileInfo::release_checksum() {
  clear_has_checksum();
  if (checksum_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = checksum_;
    checksum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ServiceResponse_FileStatus_FileInfo::set_allocated_checksum(::std::string* checksum) {
  if (checksum_ != &::google::protobuf::internal::kEmptyString) {
    delete checksum_;
  }
  if (checksum) {
    set_has_checksum();
    checksum_ = checksum;
  } else {
    clear_has_checksum();
    checksum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 retriesCount = 8;
inline bool ServiceResponse_FileStatus_FileInfo::has_retriescount() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ServiceResponse_FileStatus_FileInfo::set_has_retriescount() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ServiceResponse_FileStatus_FileInfo::clear_has_retriescount() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ServiceResponse_FileStatus_FileInfo::clear_retriescount() {
  retriescount_ = 0u;
  clear_has_retriescount();
}
inline ::google::protobuf::uint32 ServiceResponse_FileStatus_FileInfo::retriescount() const {
  return retriescount_;
}
inline void ServiceResponse_FileStatus_FileInfo::set_retriescount(::google::protobuf::uint32 value) {
  set_has_retriescount();
  retriescount_ = value;
}

// optional uint64 bytesProcessed = 9;
inline bool ServiceResponse_FileStatus_FileInfo::has_bytesprocessed() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ServiceResponse_FileStatus_FileInfo::set_has_bytesprocessed() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ServiceResponse_FileStatus_FileInfo::clear_has_bytesprocessed() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ServiceResponse_FileStatus_FileInfo::clear_bytesprocessed() {
  bytesprocessed_ = GOOGLE_ULONGLONG(0);
  clear_has_bytesprocessed();
}
inline ::google::protobuf::uint64 ServiceResponse_FileStatus_FileInfo::bytesprocessed() const {
  return bytesprocessed_;
}
inline void ServiceResponse_FileStatus_FileInfo::set_bytesprocessed(::google::protobuf::uint64 value) {
  set_has_bytesprocessed();
  bytesprocessed_ = value;
}

// optional string additionalMessage = 10;
inline bool ServiceResponse_FileStatus_FileInfo::has_additionalmessage() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ServiceResponse_FileStatus_FileInfo::set_has_additionalmessage() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ServiceResponse_FileStatus_FileInfo::clear_has_additionalmessage() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ServiceResponse_FileStatus_FileInfo::clear_additionalmessage() {
  if (additionalmessage_ != &::google::protobuf::internal::kEmptyString) {
    additionalmessage_->clear();
  }
  clear_has_additionalmessage();
}
inline const ::std::string& ServiceResponse_FileStatus_FileInfo::additionalmessage() const {
  return *additionalmessage_;
}
inline void ServiceResponse_FileStatus_FileInfo::set_additionalmessage(const ::std::string& value) {
  set_has_additionalmessage();
  if (additionalmessage_ == &::google::protobuf::internal::kEmptyString) {
    additionalmessage_ = new ::std::string;
  }
  additionalmessage_->assign(value);
}
inline void ServiceResponse_FileStatus_FileInfo::set_additionalmessage(const char* value) {
  set_has_additionalmessage();
  if (additionalmessage_ == &::google::protobuf::internal::kEmptyString) {
    additionalmessage_ = new ::std::string;
  }
  additionalmessage_->assign(value);
}
inline void ServiceResponse_FileStatus_FileInfo::set_additionalmessage(const char* value, size_t size) {
  set_has_additionalmessage();
  if (additionalmessage_ == &::google::protobuf::internal::kEmptyString) {
    additionalmessage_ = new ::std::string;
  }
  additionalmessage_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServiceResponse_FileStatus_FileInfo::mutable_additionalmessage() {
  set_has_additionalmessage();
  if (additionalmessage_ == &::google::protobuf::internal::kEmptyString) {
    additionalmessage_ = new ::std::string;
  }
  return additionalmessage_;
}
inline ::std::string* ServiceResponse_FileStatus_FileInfo::release_additionalmessage() {
  clear_has_additionalmessage();
  if (additionalmessage_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = additionalmessage_;
    additionalmessage_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ServiceResponse_FileStatus_FileInfo::set_allocated_additionalmessage(::std::string* additionalmessage) {
  if (additionalmessage_ != &::google::protobuf::internal::kEmptyString) {
    delete additionalmessage_;
  }
  if (additionalmessage) {
    set_has_additionalmessage();
    additionalmessage_ = additionalmessage;
  } else {
    clear_has_additionalmessage();
    additionalmessage_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 uploadDate = 11;
inline bool ServiceResponse_FileStatus_FileInfo::has_uploaddate() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ServiceResponse_FileStatus_FileInfo::set_has_uploaddate() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ServiceResponse_FileStatus_FileInfo::clear_has_uploaddate() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ServiceResponse_FileStatus_FileInfo::clear_uploaddate() {
  uploaddate_ = GOOGLE_ULONGLONG(0);
  clear_has_uploaddate();
}
inline ::google::protobuf::uint64 ServiceResponse_FileStatus_FileInfo::uploaddate() const {
  return uploaddate_;
}
inline void ServiceResponse_FileStatus_FileInfo::set_uploaddate(::google::protobuf::uint64 value) {
  set_has_uploaddate();
  uploaddate_ = value;
}

// -------------------------------------------------------------------

// ServiceResponse_FileStatus

// required .uploadercontrol.InfoType responseType = 1;
inline bool ServiceResponse_FileStatus::has_responsetype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServiceResponse_FileStatus::set_has_responsetype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServiceResponse_FileStatus::clear_has_responsetype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServiceResponse_FileStatus::clear_responsetype() {
  responsetype_ = 1;
  clear_has_responsetype();
}
inline ::uploadercontrol::InfoType ServiceResponse_FileStatus::responsetype() const {
  return static_cast< ::uploadercontrol::InfoType >(responsetype_);
}
inline void ServiceResponse_FileStatus::set_responsetype(::uploadercontrol::InfoType value) {
  assert(::uploadercontrol::InfoType_IsValid(value));
  set_has_responsetype();
  responsetype_ = value;
}

// optional string login = 2;
inline bool ServiceResponse_FileStatus::has_login() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ServiceResponse_FileStatus::set_has_login() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ServiceResponse_FileStatus::clear_has_login() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ServiceResponse_FileStatus::clear_login() {
  if (login_ != &::google::protobuf::internal::kEmptyString) {
    login_->clear();
  }
  clear_has_login();
}
inline const ::std::string& ServiceResponse_FileStatus::login() const {
  return *login_;
}
inline void ServiceResponse_FileStatus::set_login(const ::std::string& value) {
  set_has_login();
  if (login_ == &::google::protobuf::internal::kEmptyString) {
    login_ = new ::std::string;
  }
  login_->assign(value);
}
inline void ServiceResponse_FileStatus::set_login(const char* value) {
  set_has_login();
  if (login_ == &::google::protobuf::internal::kEmptyString) {
    login_ = new ::std::string;
  }
  login_->assign(value);
}
inline void ServiceResponse_FileStatus::set_login(const char* value, size_t size) {
  set_has_login();
  if (login_ == &::google::protobuf::internal::kEmptyString) {
    login_ = new ::std::string;
  }
  login_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServiceResponse_FileStatus::mutable_login() {
  set_has_login();
  if (login_ == &::google::protobuf::internal::kEmptyString) {
    login_ = new ::std::string;
  }
  return login_;
}
inline ::std::string* ServiceResponse_FileStatus::release_login() {
  clear_has_login();
  if (login_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = login_;
    login_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ServiceResponse_FileStatus::set_allocated_login(::std::string* login) {
  if (login_ != &::google::protobuf::internal::kEmptyString) {
    delete login_;
  }
  if (login) {
    set_has_login();
    login_ = login;
  } else {
    clear_has_login();
    login_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .uploadercontrol.ServiceResponse.FileStatus.FileInfo infos = 3;
inline int ServiceResponse_FileStatus::infos_size() const {
  return infos_.size();
}
inline void ServiceResponse_FileStatus::clear_infos() {
  infos_.Clear();
}
inline const ::uploadercontrol::ServiceResponse_FileStatus_FileInfo& ServiceResponse_FileStatus::infos(int index) const {
  return infos_.Get(index);
}
inline ::uploadercontrol::ServiceResponse_FileStatus_FileInfo* ServiceResponse_FileStatus::mutable_infos(int index) {
  return infos_.Mutable(index);
}
inline ::uploadercontrol::ServiceResponse_FileStatus_FileInfo* ServiceResponse_FileStatus::add_infos() {
  return infos_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::uploadercontrol::ServiceResponse_FileStatus_FileInfo >&
ServiceResponse_FileStatus::infos() const {
  return infos_;
}
inline ::google::protobuf::RepeatedPtrField< ::uploadercontrol::ServiceResponse_FileStatus_FileInfo >*
ServiceResponse_FileStatus::mutable_infos() {
  return &infos_;
}

// -------------------------------------------------------------------

// ServiceResponse_CopyingStatus

// required uint32 filesTotal = 1;
inline bool ServiceResponse_CopyingStatus::has_filestotal() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServiceResponse_CopyingStatus::set_has_filestotal() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServiceResponse_CopyingStatus::clear_has_filestotal() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServiceResponse_CopyingStatus::clear_filestotal() {
  filestotal_ = 0u;
  clear_has_filestotal();
}
inline ::google::protobuf::uint32 ServiceResponse_CopyingStatus::filestotal() const {
  return filestotal_;
}
inline void ServiceResponse_CopyingStatus::set_filestotal(::google::protobuf::uint32 value) {
  set_has_filestotal();
  filestotal_ = value;
}

// required uint32 filesCopied = 2;
inline bool ServiceResponse_CopyingStatus::has_filescopied() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ServiceResponse_CopyingStatus::set_has_filescopied() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ServiceResponse_CopyingStatus::clear_has_filescopied() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ServiceResponse_CopyingStatus::clear_filescopied() {
  filescopied_ = 0u;
  clear_has_filescopied();
}
inline ::google::protobuf::uint32 ServiceResponse_CopyingStatus::filescopied() const {
  return filescopied_;
}
inline void ServiceResponse_CopyingStatus::set_filescopied(::google::protobuf::uint32 value) {
  set_has_filescopied();
  filescopied_ = value;
}

// optional string login = 3;
inline bool ServiceResponse_CopyingStatus::has_login() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ServiceResponse_CopyingStatus::set_has_login() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ServiceResponse_CopyingStatus::clear_has_login() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ServiceResponse_CopyingStatus::clear_login() {
  if (login_ != &::google::protobuf::internal::kEmptyString) {
    login_->clear();
  }
  clear_has_login();
}
inline const ::std::string& ServiceResponse_CopyingStatus::login() const {
  return *login_;
}
inline void ServiceResponse_CopyingStatus::set_login(const ::std::string& value) {
  set_has_login();
  if (login_ == &::google::protobuf::internal::kEmptyString) {
    login_ = new ::std::string;
  }
  login_->assign(value);
}
inline void ServiceResponse_CopyingStatus::set_login(const char* value) {
  set_has_login();
  if (login_ == &::google::protobuf::internal::kEmptyString) {
    login_ = new ::std::string;
  }
  login_->assign(value);
}
inline void ServiceResponse_CopyingStatus::set_login(const char* value, size_t size) {
  set_has_login();
  if (login_ == &::google::protobuf::internal::kEmptyString) {
    login_ = new ::std::string;
  }
  login_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServiceResponse_CopyingStatus::mutable_login() {
  set_has_login();
  if (login_ == &::google::protobuf::internal::kEmptyString) {
    login_ = new ::std::string;
  }
  return login_;
}
inline ::std::string* ServiceResponse_CopyingStatus::release_login() {
  clear_has_login();
  if (login_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = login_;
    login_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ServiceResponse_CopyingStatus::set_allocated_login(::std::string* login) {
  if (login_ != &::google::protobuf::internal::kEmptyString) {
    delete login_;
  }
  if (login) {
    set_has_login();
    login_ = login;
  } else {
    clear_has_login();
    login_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ServiceResponse_MaintenanceStatus

// required bool isPaused = 1;
inline bool ServiceResponse_MaintenanceStatus::has_ispaused() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServiceResponse_MaintenanceStatus::set_has_ispaused() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServiceResponse_MaintenanceStatus::clear_has_ispaused() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServiceResponse_MaintenanceStatus::clear_ispaused() {
  ispaused_ = false;
  clear_has_ispaused();
}
inline bool ServiceResponse_MaintenanceStatus::ispaused() const {
  return ispaused_;
}
inline void ServiceResponse_MaintenanceStatus::set_ispaused(bool value) {
  set_has_ispaused();
  ispaused_ = value;
}

// -------------------------------------------------------------------

// ServiceResponse_Error

// required .uploadercontrol.ErrorType error = 1;
inline bool ServiceResponse_Error::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServiceResponse_Error::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServiceResponse_Error::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServiceResponse_Error::clear_error() {
  error_ = 1;
  clear_has_error();
}
inline ::uploadercontrol::ErrorType ServiceResponse_Error::error() const {
  return static_cast< ::uploadercontrol::ErrorType >(error_);
}
inline void ServiceResponse_Error::set_error(::uploadercontrol::ErrorType value) {
  assert(::uploadercontrol::ErrorType_IsValid(value));
  set_has_error();
  error_ = value;
}

// required string message = 2;
inline bool ServiceResponse_Error::has_message() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ServiceResponse_Error::set_has_message() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ServiceResponse_Error::clear_has_message() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ServiceResponse_Error::clear_message() {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    message_->clear();
  }
  clear_has_message();
}
inline const ::std::string& ServiceResponse_Error::message() const {
  return *message_;
}
inline void ServiceResponse_Error::set_message(const ::std::string& value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void ServiceResponse_Error::set_message(const char* value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void ServiceResponse_Error::set_message(const char* value, size_t size) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServiceResponse_Error::mutable_message() {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  return message_;
}
inline ::std::string* ServiceResponse_Error::release_message() {
  clear_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = message_;
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ServiceResponse_Error::set_allocated_message(::std::string* message) {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    delete message_;
  }
  if (message) {
    set_has_message();
    message_ = message;
  } else {
    clear_has_message();
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ServiceResponse_FileList_Item

// required bool isFolder = 1;
inline bool ServiceResponse_FileList_Item::has_isfolder() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServiceResponse_FileList_Item::set_has_isfolder() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServiceResponse_FileList_Item::clear_has_isfolder() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServiceResponse_FileList_Item::clear_isfolder() {
  isfolder_ = false;
  clear_has_isfolder();
}
inline bool ServiceResponse_FileList_Item::isfolder() const {
  return isfolder_;
}
inline void ServiceResponse_FileList_Item::set_isfolder(bool value) {
  set_has_isfolder();
  isfolder_ = value;
}

// required string name = 2;
inline bool ServiceResponse_FileList_Item::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ServiceResponse_FileList_Item::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ServiceResponse_FileList_Item::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ServiceResponse_FileList_Item::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ServiceResponse_FileList_Item::name() const {
  return *name_;
}
inline void ServiceResponse_FileList_Item::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ServiceResponse_FileList_Item::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ServiceResponse_FileList_Item::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServiceResponse_FileList_Item::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* ServiceResponse_FileList_Item::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ServiceResponse_FileList_Item::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ServiceResponse_FileList

// repeated .uploadercontrol.ServiceResponse.FileList.Item list = 1;
inline int ServiceResponse_FileList::list_size() const {
  return list_.size();
}
inline void ServiceResponse_FileList::clear_list() {
  list_.Clear();
}
inline const ::uploadercontrol::ServiceResponse_FileList_Item& ServiceResponse_FileList::list(int index) const {
  return list_.Get(index);
}
inline ::uploadercontrol::ServiceResponse_FileList_Item* ServiceResponse_FileList::mutable_list(int index) {
  return list_.Mutable(index);
}
inline ::uploadercontrol::ServiceResponse_FileList_Item* ServiceResponse_FileList::add_list() {
  return list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::uploadercontrol::ServiceResponse_FileList_Item >&
ServiceResponse_FileList::list() const {
  return list_;
}
inline ::google::protobuf::RepeatedPtrField< ::uploadercontrol::ServiceResponse_FileList_Item >*
ServiceResponse_FileList::mutable_list() {
  return &list_;
}

// required bool folderContentRecursively = 2;
inline bool ServiceResponse_FileList::has_foldercontentrecursively() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ServiceResponse_FileList::set_has_foldercontentrecursively() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ServiceResponse_FileList::clear_has_foldercontentrecursively() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ServiceResponse_FileList::clear_foldercontentrecursively() {
  foldercontentrecursively_ = false;
  clear_has_foldercontentrecursively();
}
inline bool ServiceResponse_FileList::foldercontentrecursively() const {
  return foldercontentrecursively_;
}
inline void ServiceResponse_FileList::set_foldercontentrecursively(bool value) {
  set_has_foldercontentrecursively();
  foldercontentrecursively_ = value;
}

// -------------------------------------------------------------------

// ServiceResponse

// required .uploadercontrol.ServiceResponse.MessageType messageType = 1;
inline bool ServiceResponse::has_messagetype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServiceResponse::set_has_messagetype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServiceResponse::clear_has_messagetype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServiceResponse::clear_messagetype() {
  messagetype_ = 1;
  clear_has_messagetype();
}
inline ::uploadercontrol::ServiceResponse_MessageType ServiceResponse::messagetype() const {
  return static_cast< ::uploadercontrol::ServiceResponse_MessageType >(messagetype_);
}
inline void ServiceResponse::set_messagetype(::uploadercontrol::ServiceResponse_MessageType value) {
  assert(::uploadercontrol::ServiceResponse_MessageType_IsValid(value));
  set_has_messagetype();
  messagetype_ = value;
}

// optional .uploadercontrol.ServiceResponse.Authorization authorization = 2;
inline bool ServiceResponse::has_authorization() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ServiceResponse::set_has_authorization() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ServiceResponse::clear_has_authorization() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ServiceResponse::clear_authorization() {
  if (authorization_ != NULL) authorization_->::uploadercontrol::ServiceResponse_Authorization::Clear();
  clear_has_authorization();
}
inline const ::uploadercontrol::ServiceResponse_Authorization& ServiceResponse::authorization() const {
  return authorization_ != NULL ? *authorization_ : *default_instance_->authorization_;
}
inline ::uploadercontrol::ServiceResponse_Authorization* ServiceResponse::mutable_authorization() {
  set_has_authorization();
  if (authorization_ == NULL) authorization_ = new ::uploadercontrol::ServiceResponse_Authorization;
  return authorization_;
}
inline ::uploadercontrol::ServiceResponse_Authorization* ServiceResponse::release_authorization() {
  clear_has_authorization();
  ::uploadercontrol::ServiceResponse_Authorization* temp = authorization_;
  authorization_ = NULL;
  return temp;
}
inline void ServiceResponse::set_allocated_authorization(::uploadercontrol::ServiceResponse_Authorization* authorization) {
  delete authorization_;
  authorization_ = authorization;
  if (authorization) {
    set_has_authorization();
  } else {
    clear_has_authorization();
  }
}

// optional .uploadercontrol.ServiceResponse.FileStatus fileStatus = 3;
inline bool ServiceResponse::has_filestatus() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ServiceResponse::set_has_filestatus() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ServiceResponse::clear_has_filestatus() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ServiceResponse::clear_filestatus() {
  if (filestatus_ != NULL) filestatus_->::uploadercontrol::ServiceResponse_FileStatus::Clear();
  clear_has_filestatus();
}
inline const ::uploadercontrol::ServiceResponse_FileStatus& ServiceResponse::filestatus() const {
  return filestatus_ != NULL ? *filestatus_ : *default_instance_->filestatus_;
}
inline ::uploadercontrol::ServiceResponse_FileStatus* ServiceResponse::mutable_filestatus() {
  set_has_filestatus();
  if (filestatus_ == NULL) filestatus_ = new ::uploadercontrol::ServiceResponse_FileStatus;
  return filestatus_;
}
inline ::uploadercontrol::ServiceResponse_FileStatus* ServiceResponse::release_filestatus() {
  clear_has_filestatus();
  ::uploadercontrol::ServiceResponse_FileStatus* temp = filestatus_;
  filestatus_ = NULL;
  return temp;
}
inline void ServiceResponse::set_allocated_filestatus(::uploadercontrol::ServiceResponse_FileStatus* filestatus) {
  delete filestatus_;
  filestatus_ = filestatus;
  if (filestatus) {
    set_has_filestatus();
  } else {
    clear_has_filestatus();
  }
}

// optional .uploadercontrol.ServiceResponse.CopyingStatus copyingStatus = 4;
inline bool ServiceResponse::has_copyingstatus() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ServiceResponse::set_has_copyingstatus() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ServiceResponse::clear_has_copyingstatus() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ServiceResponse::clear_copyingstatus() {
  if (copyingstatus_ != NULL) copyingstatus_->::uploadercontrol::ServiceResponse_CopyingStatus::Clear();
  clear_has_copyingstatus();
}
inline const ::uploadercontrol::ServiceResponse_CopyingStatus& ServiceResponse::copyingstatus() const {
  return copyingstatus_ != NULL ? *copyingstatus_ : *default_instance_->copyingstatus_;
}
inline ::uploadercontrol::ServiceResponse_CopyingStatus* ServiceResponse::mutable_copyingstatus() {
  set_has_copyingstatus();
  if (copyingstatus_ == NULL) copyingstatus_ = new ::uploadercontrol::ServiceResponse_CopyingStatus;
  return copyingstatus_;
}
inline ::uploadercontrol::ServiceResponse_CopyingStatus* ServiceResponse::release_copyingstatus() {
  clear_has_copyingstatus();
  ::uploadercontrol::ServiceResponse_CopyingStatus* temp = copyingstatus_;
  copyingstatus_ = NULL;
  return temp;
}
inline void ServiceResponse::set_allocated_copyingstatus(::uploadercontrol::ServiceResponse_CopyingStatus* copyingstatus) {
  delete copyingstatus_;
  copyingstatus_ = copyingstatus;
  if (copyingstatus) {
    set_has_copyingstatus();
  } else {
    clear_has_copyingstatus();
  }
}

// optional .uploadercontrol.ServiceResponse.MaintenanceStatus maintenanceStatus = 5;
inline bool ServiceResponse::has_maintenancestatus() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ServiceResponse::set_has_maintenancestatus() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ServiceResponse::clear_has_maintenancestatus() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ServiceResponse::clear_maintenancestatus() {
  if (maintenancestatus_ != NULL) maintenancestatus_->::uploadercontrol::ServiceResponse_MaintenanceStatus::Clear();
  clear_has_maintenancestatus();
}
inline const ::uploadercontrol::ServiceResponse_MaintenanceStatus& ServiceResponse::maintenancestatus() const {
  return maintenancestatus_ != NULL ? *maintenancestatus_ : *default_instance_->maintenancestatus_;
}
inline ::uploadercontrol::ServiceResponse_MaintenanceStatus* ServiceResponse::mutable_maintenancestatus() {
  set_has_maintenancestatus();
  if (maintenancestatus_ == NULL) maintenancestatus_ = new ::uploadercontrol::ServiceResponse_MaintenanceStatus;
  return maintenancestatus_;
}
inline ::uploadercontrol::ServiceResponse_MaintenanceStatus* ServiceResponse::release_maintenancestatus() {
  clear_has_maintenancestatus();
  ::uploadercontrol::ServiceResponse_MaintenanceStatus* temp = maintenancestatus_;
  maintenancestatus_ = NULL;
  return temp;
}
inline void ServiceResponse::set_allocated_maintenancestatus(::uploadercontrol::ServiceResponse_MaintenanceStatus* maintenancestatus) {
  delete maintenancestatus_;
  maintenancestatus_ = maintenancestatus;
  if (maintenancestatus) {
    set_has_maintenancestatus();
  } else {
    clear_has_maintenancestatus();
  }
}

// optional .uploadercontrol.ServiceResponse.Error error = 6;
inline bool ServiceResponse::has_error() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ServiceResponse::set_has_error() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ServiceResponse::clear_has_error() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ServiceResponse::clear_error() {
  if (error_ != NULL) error_->::uploadercontrol::ServiceResponse_Error::Clear();
  clear_has_error();
}
inline const ::uploadercontrol::ServiceResponse_Error& ServiceResponse::error() const {
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::uploadercontrol::ServiceResponse_Error* ServiceResponse::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::uploadercontrol::ServiceResponse_Error;
  return error_;
}
inline ::uploadercontrol::ServiceResponse_Error* ServiceResponse::release_error() {
  clear_has_error();
  ::uploadercontrol::ServiceResponse_Error* temp = error_;
  error_ = NULL;
  return temp;
}
inline void ServiceResponse::set_allocated_error(::uploadercontrol::ServiceResponse_Error* error) {
  delete error_;
  error_ = error;
  if (error) {
    set_has_error();
  } else {
    clear_has_error();
  }
}

// optional .uploadercontrol.ServiceResponse.FileList fileList = 7;
inline bool ServiceResponse::has_filelist() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ServiceResponse::set_has_filelist() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ServiceResponse::clear_has_filelist() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ServiceResponse::clear_filelist() {
  if (filelist_ != NULL) filelist_->::uploadercontrol::ServiceResponse_FileList::Clear();
  clear_has_filelist();
}
inline const ::uploadercontrol::ServiceResponse_FileList& ServiceResponse::filelist() const {
  return filelist_ != NULL ? *filelist_ : *default_instance_->filelist_;
}
inline ::uploadercontrol::ServiceResponse_FileList* ServiceResponse::mutable_filelist() {
  set_has_filelist();
  if (filelist_ == NULL) filelist_ = new ::uploadercontrol::ServiceResponse_FileList;
  return filelist_;
}
inline ::uploadercontrol::ServiceResponse_FileList* ServiceResponse::release_filelist() {
  clear_has_filelist();
  ::uploadercontrol::ServiceResponse_FileList* temp = filelist_;
  filelist_ = NULL;
  return temp;
}
inline void ServiceResponse::set_allocated_filelist(::uploadercontrol::ServiceResponse_FileList* filelist) {
  delete filelist_;
  filelist_ = filelist;
  if (filelist) {
    set_has_filelist();
  } else {
    clear_has_filelist();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace uploadercontrol

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::uploadercontrol::ClientRequest_MessageType>() {
  return ::uploadercontrol::ClientRequest_MessageType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::uploadercontrol::ServiceResponse_MessageType>() {
  return ::uploadercontrol::ServiceResponse_MessageType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::uploadercontrol::FileType>() {
  return ::uploadercontrol::FileType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::uploadercontrol::CommandType>() {
  return ::uploadercontrol::CommandType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::uploadercontrol::TaskStatus>() {
  return ::uploadercontrol::TaskStatus_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::uploadercontrol::InfoType>() {
  return ::uploadercontrol::InfoType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::uploadercontrol::RequestType>() {
  return ::uploadercontrol::RequestType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::uploadercontrol::ErrorType>() {
  return ::uploadercontrol::ErrorType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_remoteclient_2eproto__INCLUDED
